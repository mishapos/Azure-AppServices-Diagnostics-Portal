export var NgFlowchart;
(function (NgFlowchart) {
    class Flow {
        constructor(canvas) {
            this.canvas = canvas;
        }
        /**
         * Returns the json representation of this flow
         * @param indent Optional indent to specify for formatting
         */
        toJSON(indent) {
            return JSON.stringify(this.toObject(), null, indent);
        }
        toObject() {
            return {
                root: this.canvas.flow.rootStep?.toJSON()
            };
        }
        /**
         * Create a flow and render it on the canvas from a json string
         * @param json The json string of the flow to render
         */
        async upload(json) {
            let jsonObj = typeof json === 'string' ? JSON.parse(json) : json;
            let root = jsonObj.root;
            this.clear();
            await this.canvas.upload(root);
        }
        /**
         * Returns the root step of the flow chart
         */
        getRoot() {
            return this.canvas.flow.rootStep;
        }
        /**
         * Finds a step in the flow chart by a given id
         * @param id Id of the step to find. By default, the html id of the step
         */
        getStep(id) {
            return this.canvas.flow.steps.find(child => child.id == id);
        }
        /**
         * Re-renders the canvas. Generally this should only be used in rare circumstances
         * @param pretty Attempt to recenter the flow in the canvas
         */
        render(pretty) {
            this.canvas.reRender(pretty);
        }
        /**
         * Clears all flow chart, reseting the current canvas
         */
        clear() {
            if (this.canvas.flow?.rootStep) {
                this.canvas.flow.rootStep.destroy(true, false);
                this.canvas.reRender();
            }
        }
    }
    NgFlowchart.Flow = Flow;
    class Options {
        constructor() {
            /** The gap (in pixels) between flow steps*/
            this.stepGap = 40;
            /** An inner deadzone radius (in pixels) that will not register the hover icon  */
            this.hoverDeadzoneRadius = 20;
            /** Is the flow sequential? If true, then you will not be able to drag parallel steps */
            this.isSequential = false;
            /** The default root position when dropped. Default is TOP_CENTER */
            this.rootPosition = 'TOP_CENTER';
            /** Should the canvas be centered when a resize is detected? */
            this.centerOnResize = true;
            /** Canvas zoom options. Defaults to mouse wheel zoom */
            this.zoom = {
                mode: 'WHEEL',
                defaultStep: .1
            };
        }
    }
    NgFlowchart.Options = Options;
})(NgFlowchart || (NgFlowchart = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxvdy5tb2RlbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvbW9kZWwvZmxvdy5tb2RlbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQSxNQUFNLEtBQVcsV0FBVyxDQWlNM0I7QUFqTUQsV0FBaUIsV0FBVztJQUN4QixNQUFhLElBQUk7UUFDYixZQUFvQixNQUFnQztZQUFoQyxXQUFNLEdBQU4sTUFBTSxDQUEwQjtRQUVwRCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0gsTUFBTSxDQUFDLE1BQWU7WUFDbEIsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDekQsQ0FBQztRQUVELFFBQVE7WUFDSixPQUFPO2dCQUNILElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFO2FBQzVDLENBQUE7UUFDTCxDQUFDO1FBRUQ7OztXQUdHO1FBQ0gsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFxQjtZQUM5QixJQUFJLE9BQU8sR0FBRyxPQUFPLElBQUksS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQTtZQUNoRSxJQUFJLElBQUksR0FBUSxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQzdCLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUViLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkMsQ0FBQztRQUVEOztXQUVHO1FBQ0gsT0FBTztZQUNILE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3JDLENBQUM7UUFFRDs7O1dBR0c7UUFDSCxPQUFPLENBQUMsRUFBRTtZQUNOLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDaEUsQ0FBQztRQUVEOzs7V0FHRztRQUNILE1BQU0sQ0FBQyxNQUFnQjtZQUNuQixJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNqQyxDQUFDO1FBRUQ7O1dBRUc7UUFDSCxLQUFLO1lBQ0QsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxRQUFRLEVBQUU7Z0JBQzVCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUMvQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDO2FBQzFCO1FBQ0wsQ0FBQztLQUVKO0lBaEVZLGdCQUFJLE9BZ0VoQixDQUFBO0lBRUQsTUFBYSxPQUFPO1FBQXBCO1lBQ0ksNENBQTRDO1lBQzVDLFlBQU8sR0FBWSxFQUFFLENBQUM7WUFFdEIsa0ZBQWtGO1lBQ2xGLHdCQUFtQixHQUFZLEVBQUUsQ0FBQztZQUVsQyx3RkFBd0Y7WUFDeEYsaUJBQVksR0FBYSxLQUFLLENBQUM7WUFFL0Isb0VBQW9FO1lBQ3BFLGlCQUFZLEdBQXNDLFlBQVksQ0FBQztZQUUvRCwrREFBK0Q7WUFDL0QsbUJBQWMsR0FBYSxJQUFJLENBQUM7WUFFaEMsd0RBQXdEO1lBQ3hELFNBQUksR0FHQTtnQkFDQSxJQUFJLEVBQUUsT0FBTztnQkFDYixXQUFXLEVBQUUsRUFBRTthQUNsQixDQUFBO1FBQ0wsQ0FBQztLQUFBO0lBeEJZLG1CQUFPLFVBd0JuQixDQUFBO0FBc0dMLENBQUMsRUFqTWdCLFdBQVcsS0FBWCxXQUFXLFFBaU0zQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRlbXBsYXRlUmVmLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE5nRmxvd2NoYXJ0Q2FudmFzU2VydmljZSB9IGZyb20gJy4uL25nLWZsb3djaGFydC1jYW52YXMuc2VydmljZSc7XHJcbmltcG9ydCB7IE5nRmxvd2NoYXJ0U3RlcENvbXBvbmVudCB9IGZyb20gJy4uL25nLWZsb3djaGFydC1zdGVwL25nLWZsb3djaGFydC1zdGVwLmNvbXBvbmVudCc7XHJcblxyXG5leHBvcnQgbmFtZXNwYWNlIE5nRmxvd2NoYXJ0IHtcclxuICAgIGV4cG9ydCBjbGFzcyBGbG93IHtcclxuICAgICAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNhbnZhczogTmdGbG93Y2hhcnRDYW52YXNTZXJ2aWNlKSB7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUganNvbiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZsb3dcclxuICAgICAgICAgKiBAcGFyYW0gaW5kZW50IE9wdGlvbmFsIGluZGVudCB0byBzcGVjaWZ5IGZvciBmb3JtYXR0aW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdG9KU09OKGluZGVudD86IG51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b09iamVjdCgpLCBudWxsLCBpbmRlbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdG9PYmplY3QoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICByb290OiB0aGlzLmNhbnZhcy5mbG93LnJvb3RTdGVwPy50b0pTT04oKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGUgYSBmbG93IGFuZCByZW5kZXIgaXQgb24gdGhlIGNhbnZhcyBmcm9tIGEganNvbiBzdHJpbmdcclxuICAgICAgICAgKiBAcGFyYW0ganNvbiBUaGUganNvbiBzdHJpbmcgb2YgdGhlIGZsb3cgdG8gcmVuZGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYXN5bmMgdXBsb2FkKGpzb246IHN0cmluZyB8IG9iamVjdCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgICAgICBsZXQganNvbk9iaiA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uXHJcbiAgICAgICAgICAgIGxldCByb290OiBhbnkgPSBqc29uT2JqLnJvb3Q7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2FudmFzLnVwbG9hZChyb290KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJvb3Qgc3RlcCBvZiB0aGUgZmxvdyBjaGFydFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFJvb3QoKTogTmdGbG93Y2hhcnRTdGVwQ29tcG9uZW50IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmZsb3cucm9vdFN0ZXA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kcyBhIHN0ZXAgaW4gdGhlIGZsb3cgY2hhcnQgYnkgYSBnaXZlbiBpZFxyXG4gICAgICAgICAqIEBwYXJhbSBpZCBJZCBvZiB0aGUgc3RlcCB0byBmaW5kLiBCeSBkZWZhdWx0LCB0aGUgaHRtbCBpZCBvZiB0aGUgc3RlcFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFN0ZXAoaWQpOiBOZ0Zsb3djaGFydFN0ZXBDb21wb25lbnQge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuZmxvdy5zdGVwcy5maW5kKGNoaWxkID0+IGNoaWxkLmlkID09IGlkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlLXJlbmRlcnMgdGhlIGNhbnZhcy4gR2VuZXJhbGx5IHRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiByYXJlIGNpcmN1bXN0YW5jZXNcclxuICAgICAgICAgKiBAcGFyYW0gcHJldHR5IEF0dGVtcHQgdG8gcmVjZW50ZXIgdGhlIGZsb3cgaW4gdGhlIGNhbnZhc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlbmRlcihwcmV0dHk/OiBib29sZWFuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnJlUmVuZGVyKHByZXR0eSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGVhcnMgYWxsIGZsb3cgY2hhcnQsIHJlc2V0aW5nIHRoZSBjdXJyZW50IGNhbnZhc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsZWFyKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMuZmxvdz8ucm9vdFN0ZXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLmZsb3cucm9vdFN0ZXAuZGVzdHJveSh0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5yZVJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgY2xhc3MgT3B0aW9ucyB7XHJcbiAgICAgICAgLyoqIFRoZSBnYXAgKGluIHBpeGVscykgYmV0d2VlbiBmbG93IHN0ZXBzKi9cclxuICAgICAgICBzdGVwR2FwPzogbnVtYmVyID0gNDA7XHJcblxyXG4gICAgICAgIC8qKiBBbiBpbm5lciBkZWFkem9uZSByYWRpdXMgKGluIHBpeGVscykgdGhhdCB3aWxsIG5vdCByZWdpc3RlciB0aGUgaG92ZXIgaWNvbiAgKi9cclxuICAgICAgICBob3ZlckRlYWR6b25lUmFkaXVzPzogbnVtYmVyID0gMjA7XHJcblxyXG4gICAgICAgIC8qKiBJcyB0aGUgZmxvdyBzZXF1ZW50aWFsPyBJZiB0cnVlLCB0aGVuIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGRyYWcgcGFyYWxsZWwgc3RlcHMgKi9cclxuICAgICAgICBpc1NlcXVlbnRpYWw/OiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8qKiBUaGUgZGVmYXVsdCByb290IHBvc2l0aW9uIHdoZW4gZHJvcHBlZC4gRGVmYXVsdCBpcyBUT1BfQ0VOVEVSICovXHJcbiAgICAgICAgcm9vdFBvc2l0aW9uPzogJ1RPUF9DRU5URVInIHwgJ0NFTlRFUicgfCAnRlJFRScgPSAnVE9QX0NFTlRFUic7XHJcblxyXG4gICAgICAgIC8qKiBTaG91bGQgdGhlIGNhbnZhcyBiZSBjZW50ZXJlZCB3aGVuIGEgcmVzaXplIGlzIGRldGVjdGVkPyAqL1xyXG4gICAgICAgIGNlbnRlck9uUmVzaXplPzogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgICAgIC8qKiBDYW52YXMgem9vbSBvcHRpb25zLiBEZWZhdWx0cyB0byBtb3VzZSB3aGVlbCB6b29tICovXHJcbiAgICAgICAgem9vbT86IHtcclxuICAgICAgICAgICAgbW9kZTogJ1dIRUVMJyB8ICdNQU5VQUwnIHwgJ0RJU0FCTEVEJ1xyXG4gICAgICAgICAgICBkZWZhdWx0U3RlcD86IG51bWJlclxyXG4gICAgICAgIH0gPSB7XHJcbiAgICAgICAgICAgIG1vZGU6ICdXSEVFTCcsXHJcbiAgICAgICAgICAgIGRlZmF1bHRTdGVwOiAuMVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgdHlwZSBEcm9wRXZlbnQgPSB7XHJcbiAgICAgICAgc3RlcDogTmdGbG93Y2hhcnRTdGVwQ29tcG9uZW50LFxyXG4gICAgICAgIHBhcmVudD86IE5nRmxvd2NoYXJ0U3RlcENvbXBvbmVudCxcclxuICAgICAgICBpc01vdmU6IGJvb2xlYW5cclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgdHlwZSBEcm9wRXJyb3IgPSB7XHJcbiAgICAgICAgc3RlcDogUGVuZGluZ1N0ZXAsXHJcbiAgICAgICAgcGFyZW50PzogTmdGbG93Y2hhcnRTdGVwQ29tcG9uZW50LFxyXG4gICAgICAgIGVycm9yOiBFcnJvck1lc3NhZ2VcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgdHlwZSBNb3ZlRXJyb3IgPSB7XHJcbiAgICAgICAgc3RlcDogTW92ZVN0ZXAsXHJcbiAgICAgICAgcGFyZW50PzogTmdGbG93Y2hhcnRTdGVwQ29tcG9uZW50LFxyXG4gICAgICAgIGVycm9yOiBFcnJvck1lc3NhZ2VcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgdHlwZSBFcnJvck1lc3NhZ2UgPSB7XHJcbiAgICAgICAgY29kZT86IHN0cmluZyxcclxuICAgICAgICBtZXNzYWdlPzogc3RyaW5nXHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IGludGVyZmFjZSBNb3ZlU3RlcCBleHRlbmRzIFN0ZXAge1xyXG4gICAgICAgIGluc3RhbmNlOiBOZ0Zsb3djaGFydFN0ZXBDb21wb25lbnRcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnQgaW50ZXJmYWNlIFBlbmRpbmdTdGVwIGV4dGVuZHMgU3RlcCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gTmctdGVtcGxhdGUgY29udGFpbmluZyB0aGUgY2FudmFzIGNvbnRlbnQgdG8gYmUgZGlzcGxheWVkLiBcclxuICAgICAgICAgKiBPciBhIGNvbXBvbmVudCB0eXBlIHRoYXQgZXh0ZW5kcyBOZ0Zsb3djaGFydFN0ZXBDb21wb25lbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PiB8IFR5cGU8TmdGbG93Y2hhcnRTdGVwQ29tcG9uZW50PlxyXG4gICAgfVxyXG5cclxuICAgIGV4cG9ydCBpbnRlcmZhY2UgU3RlcCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSB1bmlxdWUgc3RyaW5nIGluZGljYXRpbmcgdGhlIHR5cGUgb2Ygc3RlcCB0aGlzIGlzLlxyXG4gICAgICAgICAqIFRoaXMgdHlwZSB3aWxsIGJlIHVzZWQgdG8gcmVnaXN0ZXIgc3RlcHMgaWYgeW91IGFyZSB1cGxvYWRpbmcgZnJvbSBqc29uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHR5cGU6IHN0cmluZyxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPcHRpb25hbCBkYXRhIHRvIGdpdmUgdGhlIHN0ZXAuIFR5cGljYWxseSBjb25maWd1cmF0aW9uIGRhdGEgdGhhdCB1c2VycyBjYW4gZWRpdCBvbiB0aGUgc3RlcC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBkYXRhPzogYW55XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICBleHBvcnQgdHlwZSBEcm9wVGFyZ2V0ID0ge1xyXG4gICAgICAgIHN0ZXA6IE5nRmxvd2NoYXJ0U3RlcENvbXBvbmVudCxcclxuICAgICAgICBwb3NpdGlvbjogRHJvcFBvc2l0aW9uXHJcbiAgICB9XHJcblxyXG4gICAgZXhwb3J0IHR5cGUgRHJvcFN0YXR1cyA9ICdTVUNDRVNTJyB8ICdQRU5ESU5HJyB8ICdGQUlMRUQnO1xyXG4gICAgZXhwb3J0IHR5cGUgRHJvcFBvc2l0aW9uID0gJ1JJR0hUJyB8ICdMRUZUJyB8ICdCRUxPVycgfCAnQUJPVkUnO1xyXG5cclxuICAgIGV4cG9ydCB0eXBlIENhbGxiYWNrcyA9IHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gdXNlciBkcm9wcyBhIG5ldyBzdGVwIGZyb20gdGhlIHBhbGV0dGUgb3IgbW92ZXMgYW4gZXhpc3Rpbmcgc3RlcFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uRHJvcFN0ZXA/OiAoZHJvcDogRHJvcEV2ZW50KSA9PiB2b2lkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgZGVsZXRlIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQgb24gdGhlIHN0ZXBcclxuICAgICAgICAgKi9cclxuICAgICAgICBiZWZvcmVEZWxldGVTdGVwPzogKHN0ZXA6IE5nRmxvd2NoYXJ0U3RlcENvbXBvbmVudCkgPT4gdm9pZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGVkIGFmdGVyIHRoZSBkZWxldGUgbWV0aG9kIGhhcyBydW4gb24gdGhlIHN0ZXAuIElmIHlvdSBuZWVkIHRvIGFjY2Vzc1xyXG4gICAgICAgICAqIHN0ZXAgY2hpbGRyZW4gb3IgcGFyZW50cywgdXNlIGJlZm9yZURlbGV0ZVN0ZXBcclxuICAgICAgICAgKi9cclxuICAgICAgICBhZnRlckRlbGV0ZVN0ZXA/OiAoc3RlcDogTmdGbG93Y2hhcnRTdGVwQ29tcG9uZW50KSA9PiB2b2lkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgd2hlbiBhIG5ldyBzdGVwIGZhaWxzIHRvIGRyb3Agb24gdGhlIGNhbnZhc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uRHJvcEVycm9yPzogKGRyb3A6IERyb3BFcnJvcikgPT4gdm9pZDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gYW4gZXhpc3Rpbmcgc3RlcCBmYWlscyB0byBtb3ZlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25Nb3ZlRXJyb3I/OiAoZHJvcDogTW92ZUVycm9yKSA9PiB2b2lkO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYmVmb3JlIHRoZSBjYW52YXMgaXMgYWJvdXQgdG8gcmUtcmVuZGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgYmVmb3JlUmVuZGVyPzogKCkgPT4gdm9pZFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGNhbnZhcyBjb21wbGV0ZXMgYSByZS1yZW5kZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBhZnRlclJlbmRlcj86ICgpID0+IHZvaWQgICAgICAgIFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGNhbnZhcyBoYXMgYmVlbiBzY2FsZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBhZnRlclNjYWxlPzogKG5ld1NjYWxlOiBudW1iZXIpID0+IHZvaWRcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbiJdfQ==