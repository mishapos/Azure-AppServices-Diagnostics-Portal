{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","../../src/lib/model/flow.model.ts","../../src/lib/model/flowchart.constants.ts","../../src/lib/ng-flowchart-arrow/ng-flowchart-arrow.component.ts","../../src/lib/ng-flowchart-step/ng-flowchart-step.component.ts","../../src/lib/services/options.service.ts","../../src/lib/services/canvas-renderer.service.ts","../../src/lib/services/dropdata.service.ts","../../src/lib/ng-flowchart-step-registry.service.ts","../../src/lib/services/step-manager.service.ts","../../src/lib/ng-flowchart-canvas.service.ts","../../src/lib/ng-flowchart-canvas.directive.ts","../../src/lib/ng-flowchart-step.directive.ts","../../src/lib/ng-flowchart.module.ts"],"names":["__generator","thisArg","body","f","y","t","g","_","label","sent","trys","ops","next","verb","throw","return","Symbol","iterator","this","n","v","op","TypeError","call","done","value","pop","length","push","e","step","Object","create","__read","o","m","r","i","ar","error","__spread","arguments","concat","NgFlowchart","Flow","canvas","prototype","toJSON","indent","JSON","stringify","toObject","root","_a","flow","rootStep","upload","json","jsonObj","parse","clear","_b","getRoot","getStep","id","steps","find","child","render","pretty","reRender","destroy","Options","stepGap","hoverDeadzoneRadius","isSequential","rootPosition","centerOnResize","zoom","mode","defaultStep","CONSTANTS","NgFlowchartArrowComponent","opacity","containerWidth","containerHeight","containerLeft","containerTop","padding","isLeftFlowing","defineProperty","pos","_position","start","end","Math","abs","min","updatePath","ngOnInit","ngAfterViewInit","hideArrow","showArrow","arrow","nativeElement","setAttribute","Component","args","selector","template","ViewChild","Input","NgFlowchartStepComponent","viewInit","EventEmitter","_currentPosition","_isHidden","_children","onMoveStart","event","disabled","hideTree","dataTransfer","setData","drop","dragStep","type","data","instance","onMoveEnd","showTree","init","viewContainer","compFactory","canDeleteStep","canDrop","dropEvent","shouldEvalDropHover","coords","stepToDrop","onUpload","getDropPositionsForStep","classList","add","_initPosition","zsetPosition","emit","_id","Date","now","addChild","pending","options","createStep","componentRef","addToCanvas","sibling","zaddChildSibling0","index","zaddChild0","addStep","recursive","checkCallbacks","callbacks","beforeDeleteStep","parentIndex","_parent","removeChild","destroy0","afterDeleteStep","childToRemove","children","findIndex","splice","setParent","newParent","force","parent","console","warn","clearHoverIcons","removeAttribute","showHoverIcon","position","toLowerCase","isRootElement","hasChildren","count","getNodeTreeWidth","currentNodeWidth","getBoundingClientRect","width","childWidth","reduce","childTreeWidth","max","isHidden","getCurrentRect","canvasRect","clientRect","bottom","height","top","left","right","map","view","setId","offsetCenter","adjustedX","offsetWidth","adjustedY","offsetHeight","style","newChild","oldChildIndex","newChildLastChild","findLastSingleChild","setChildren","slice","zdrawArrow","createArrow","compRef","removeStep","newRoot","factory","resolveComponentFactory","createComponent","parentElement","appendChild","location","forEach","_this","encapsulation","ViewEncapsulation","None","HostListener","Output","OptionsService","_callbacks","_options","setOptions","sanitizeOptions","setCallbacks","defaultOpts","assign","Injectable","CanvasRendererService","scale","scaleDebounceTimer","renderRoot","dragEvent","getCanvasContentElement","setRootPosition","renderNonRoot","updatePosition","relativeXY","getRelativeXY","coord","getStepGap","renderChildTree","rootNode","rootRect","childYTop","rootWidth","rootXCenter","childTreeWidths","totalTreeWidth","totalChildWidth","leftXTree","childExtent","childLeft","currentChildRect","skipAdjustDimensions","hasRoot","beforeRender","adjustDimensions","_c","afterRender","resetAdjustDimensions","canvasWrapper","minWidth","minHeight","findDropLocationForHover","absMouseXY","targetStep","stepRect","yStepCenter","xStepCenter","yDiff","xDiff","absYDistance","absXDistance","distance","sqrt","result","proximity","includes","maxRight","maxBottom","ele","rect","widthBorderGap","widthDiff","growWidth","getTotalTreeWidth","isNestedCanvas","heightDiff","growHeight","shrinkHeight","findBestMatchForSteps","absXY","clientX","clientY","bestMatch","findAndShowClosestDrop","showSnaps","clearAllSnapIndicators","canvasCenter","getCanvasCenterPosition","canvasTop","getCanvasTopCenterPosition","htmlRootElement","yCoord","scaleYOffset","element","getElementsByClassName","item","contains","resetScale","setScale","scaleUp","newScale","scaleDown","scaleValue","minDimAdjust","canvasContent","transform","transformOrigin","afterScale","clearTimeout","setTimeout","remove","DropDataService","setDragStep","ref","getDragStep","providedIn","NgFlowchartStepRegistry","registry","Map","registerStep","set","getStepImpl","get","StepManagerService","componentFactoryResolver","createFromRegistry","templateComp","TemplateRef","Type","pendingStep","contentTemplate","injector","ViewContainerRef","ComponentFactoryResolver","CanvasFlow","_steps","NgFlowchartCanvasService","drag","renderer","stepmanager","isDragging","_disabled","noParentError","code","message","indexOf","hostView","moveStep","currentDropTarget","response","addStepToFlow","prettyRender","moveError","onDropStep","isMove","onDrop","dropError","_e","dropTarget","addChildStep","setRoot","onDragStart","createStepFromType","Promise","resolve","sub","subscribe","__awaiter$3","unsubscribe","uploadNode","node","parentNode","comp","childComp","oldRoot","added","placeStepAbove","placeStepBelow","log","placeStepAdjacent","newStep","parentStep","siblingStep","isLeft","adjacentIndex","childStep","onDropError","_d","onMoveError","DragService","NgFlowchartCanvasDirective","canvasEle","optionService","createCanvasContent","closestCanvasId","target","closest","getData","onDragOver","preventDefault","onResize","onZoom","adjustWheelScale","val","ngOnDestroy","undefined","canvasId","document","createElement","getFlow","scaleVal","deltaY","Directive","providers","ElementRef","HostBinding","NgFlowchartStepDirective","flowStep","onDragEnd","NgModule","declarations","imports","CommonModule","exports","entryComponents"],"mappings":"sbA+EgBA,EAAYC,EAASC,GACjC,IAAsGC,EAAGC,EAAGC,EAAGC,EAA3GC,EAAI,CAAEC,MAAO,EAAGC,KAAM,WAAa,GAAW,EAAPJ,EAAE,GAAQ,MAAMA,EAAE,GAAI,OAAOA,EAAE,IAAOK,KAAM,GAAIC,IAAK,IAChG,OAAOL,EAAI,CAAEM,KAAMC,EAAK,GAAIC,MAASD,EAAK,GAAIE,OAAUF,EAAK,IAAwB,mBAAXG,SAA0BV,EAAEU,OAAOC,UAAY,WAAa,OAAOC,OAAUZ,EACvJ,SAASO,EAAKM,GAAK,OAAO,SAAUC,GAAK,OACzC,SAAcC,GACV,GAAIlB,EAAG,MAAM,IAAImB,UAAU,mCAC3B,KAAOf,OACH,GAAIJ,EAAI,EAAGC,IAAMC,EAAY,EAARgB,EAAG,GAASjB,EAAU,OAAIiB,EAAG,GAAKjB,EAAS,SAAOC,EAAID,EAAU,SAAMC,EAAEkB,KAAKnB,GAAI,GAAKA,EAAEQ,SAAWP,EAAIA,EAAEkB,KAAKnB,EAAGiB,EAAG,KAAKG,KAAM,OAAOnB,EAE3J,OADID,EAAI,EAAGC,IAAGgB,EAAK,CAAS,EAARA,EAAG,GAAQhB,EAAEoB,QACzBJ,EAAG,IACP,KAAK,EAAG,KAAK,EAAGhB,EAAIgB,EAAI,MACxB,KAAK,EAAc,OAAXd,EAAEC,QAAgB,CAAEiB,MAAOJ,EAAG,GAAIG,MAAM,GAChD,KAAK,EAAGjB,EAAEC,QAASJ,EAAIiB,EAAG,GAAIA,EAAK,CAAC,GAAI,SACxC,KAAK,EAAGA,EAAKd,EAAEI,IAAIe,MAAOnB,EAAEG,KAAKgB,MAAO,SACxC,QACI,KAAMrB,EAAIE,EAAEG,MAAML,EAAIA,EAAEsB,OAAS,GAAKtB,EAAEA,EAAEsB,OAAS,KAAkB,IAAVN,EAAG,IAAsB,IAAVA,EAAG,IAAW,CAAEd,EAAI,EAAG,SACjG,GAAc,IAAVc,EAAG,MAAchB,GAAMgB,EAAG,GAAKhB,EAAE,IAAMgB,EAAG,GAAKhB,EAAE,IAAM,CAAEE,EAAEC,MAAQa,EAAG,GAAI,MAC9E,GAAc,IAAVA,EAAG,IAAYd,EAAEC,MAAQH,EAAE,GAAI,CAAEE,EAAEC,MAAQH,EAAE,GAAIA,EAAIgB,EAAI,MAC7D,GAAIhB,GAAKE,EAAEC,MAAQH,EAAE,GAAI,CAAEE,EAAEC,MAAQH,EAAE,GAAIE,EAAEI,IAAIiB,KAAKP,GAAK,MACvDhB,EAAE,IAAIE,EAAEI,IAAIe,MAChBnB,EAAEG,KAAKgB,MAAO,SAEtBL,EAAKnB,EAAKqB,KAAKtB,EAASM,GAC1B,MAAOsB,GAAKR,EAAK,CAAC,EAAGQ,GAAIzB,EAAI,UAAeD,EAAIE,EAAI,EACtD,GAAY,EAARgB,EAAG,GAAQ,MAAMA,EAAG,GAAI,MAAO,CAAEI,MAAOJ,EAAG,GAAKA,EAAG,QAAK,EAAQG,MAAM,GArB9BM,CAAK,CAACX,EAAGC,MAyBhCW,OAAOC,gBA4BpBC,EAAOC,EAAGf,GACtB,IAAIgB,EAAsB,mBAAXnB,QAAyBkB,EAAElB,OAAOC,UACjD,IAAKkB,EAAG,OAAOD,EACf,IAAmBE,EAAYP,EAA3BQ,EAAIF,EAAEZ,KAAKW,GAAOI,EAAK,GAC3B,IACI,WAAc,IAANnB,GAAgBA,KAAM,MAAQiB,EAAIC,EAAEzB,QAAQY,MAAMc,EAAGV,KAAKQ,EAAEX,OAExE,MAAOc,GAASV,EAAI,CAAEU,MAAOA,WAEzB,IACQH,IAAMA,EAAEZ,OAASW,EAAIE,EAAU,SAAIF,EAAEZ,KAAKc,WAExC,GAAIR,EAAG,MAAMA,EAAEU,OAE7B,OAAOD,WAIKE,IACZ,IAAK,IAAIF,EAAK,GAAID,EAAI,EAAGA,EAAII,UAAUd,OAAQU,IAC3CC,EAAKA,EAAGI,OAAOT,EAAOQ,UAAUJ,KACpC,OAAOC,EAyDcP,OAAOC,wUCjNhC,SAAiBW,GACb,IAAAC,EAAA,WACI,SAAAA,EAAoBC,GAAA3B,KAAA2B,OAAAA,SAQpBD,EAAAE,UAAAC,OAAA,SAAOC,GACH,OAAOC,KAAKC,UAAUhC,KAAKiC,WAAY,KAAMH,IAGjDJ,EAAAE,UAAAK,SAAA,iBACI,MAAO,CACHC,KAA+B,QAA3BC,EAAEnC,KAAK2B,OAAOS,KAAKC,gBAAQ,IAAAF,OAAA,EAAAA,EAAEN,WAQnCH,EAAAE,UAAAU,OAAA,SAAOC,qGAKT,OAJIC,EAA0B,iBAATD,EAAoBR,KAAKU,MAAMF,GAAQA,EACxDL,EAAYM,EAAQN,KACxBlC,KAAK0C,QAEL,CAAA,EAAM1C,KAAK2B,OAAOW,OAAOJ,kBAAzBS,EAAApD,mBAMJmC,EAAAE,UAAAgB,QAAA,WACI,OAAO5C,KAAK2B,OAAOS,KAAKC,UAO5BX,EAAAE,UAAAiB,QAAA,SAAQC,GACJ,OAAO9C,KAAK2B,OAAOS,KAAKW,MAAMC,MAAK,SAAAC,GAAS,OAAAA,EAAMH,IAAMA,MAO5DpB,EAAAE,UAAAsB,OAAA,SAAOC,GACHnD,KAAK2B,OAAOyB,SAASD,IAMzBzB,EAAAE,UAAAc,MAAA,kBACwB,QAApBP,EAAInC,KAAK2B,OAAOS,YAAI,IAAAD,OAAA,EAAAA,EAAEE,YAClBrC,KAAK2B,OAAOS,KAAKC,SAASgB,SAAQ,GAAM,GACxCrD,KAAK2B,OAAOyB,eA5DxB,GAAa3B,EAAAC,KAAIA,EAkEjB,IAAA4B,EAAA,WAEItD,KAAAuD,QAAmB,GAGnBvD,KAAAwD,oBAA+B,GAG/BxD,KAAAyD,cAAyB,EAGzBzD,KAAA0D,aAAkD,aAGlD1D,KAAA2D,gBAA2B,EAG3B3D,KAAA4D,KAGI,CACAC,KAAM,QACNC,YAAa,KAtBRrC,EAAA6B,QAAOA,EAnExB,CAAiB7B,EAAAA,cAAAA,EAAAA,YAAW,KCJrB,IAAMsC,EACQ,yBADRA,EAEa,6BAFbA,EAIK,kCCqChB,SAAAC,IAZAhE,KAAAiE,QAAU,EACVjE,KAAAkE,eAAyB,EACzBlE,KAAAmE,gBAA0B,EAC1BnE,KAAAoE,cAAwB,EACxBpE,KAAAqE,aAAuB,EAKfrE,KAAAsE,QAAU,GACVtE,KAAAuE,eAAgB,SA3BxB1D,OAAA2D,eACIR,EAAApC,UAAA,WAAQ,KADZ,SACa6C,GACXzE,KAAK0E,UAAYD,EAEjBzE,KAAKuE,cAAgBE,EAAIE,MAAM,GAAKF,EAAIG,IAAI,GAG5C5E,KAAKkE,eAAiBW,KAAKC,IAAIL,EAAIE,MAAM,GAAKF,EAAIG,IAAI,IAAsB,EAAf5E,KAAKsE,QAElEtE,KAAKoE,cAAgBS,KAAKE,IAAIN,EAAIE,MAAM,GAAIF,EAAIG,IAAI,IAAM5E,KAAKsE,QAE/DtE,KAAKmE,gBAAkBU,KAAKC,IAAIL,EAAIE,MAAM,GAAKF,EAAIG,IAAI,IACvD5E,KAAKqE,aAAeI,EAAIE,MAAM,GAE9B3E,KAAKgF,8CAiBPhB,EAAApC,UAAAqD,SAAA,aAGAjB,EAAApC,UAAAsD,gBAAA,WACElF,KAAKgF,cAGPhB,EAAApC,UAAAuD,UAAA,WACEnF,KAAKiE,QAAU,IAGjBD,EAAApC,UAAAwD,UAAA,WACEpF,KAAKiE,QAAU,GAGTD,EAAApC,UAAAoD,WAAA,kBACS,QAAX7C,EAACnC,KAAKqF,aAAK,IAAAlD,OAAA,EAAAA,EAAEmD,iBAIbtF,KAAKuE,cACPvE,KAAKqF,MAAMC,cAAcC,aAAa,IAAK,eACtCvF,KAAKkE,eAAiBlE,KAAKsE,SAAO,kBAClCtE,KAAKkE,eAAiBlE,KAAKsE,SAAO,IAAItE,KAAKmE,gBAAkB,EAAC,cAC9DnE,KAAKsE,QAAO,IAAItE,KAAKmE,gBAAkB,EAAC,cACxCnE,KAAKsE,QAAO,KAAItE,KAAKmE,gBAAkB,GAAC,YAI7CnE,KAAKqF,MAAMC,cAAcC,aAAa,IAAK,cACtCvF,KAAKsE,QAAO,iBACZtE,KAAKsE,QAAO,IAAItE,KAAKmE,gBAAkB,EAAC,eACxCnE,KAAKkE,eAAiBlE,KAAKsE,SAAO,IAAItE,KAAKmE,gBAAkB,EAAC,eAC9DnE,KAAKkE,eAAiBlE,KAAKsE,SAAO,KAAItE,KAAKmE,gBAAkB,GAAC,uCA1ExEqB,EAAAA,UAASC,KAAA,CAAC,CACTC,SAAU,yBACVC,SAAA,u2BAKCC,EAAAA,UAASH,KAAA,CAAC,2BAGVI,EAAAA,sVCuED,SAAAC,IApBA9F,KAAA+F,SAAW,IAAIC,EAAAA,aAOPhG,KAAAiG,iBAAmB,CAAC,EAAG,GAIvBjG,KAAAkG,WAAY,EAUlBlG,KAAKmG,UAAY,UAzDnBL,EAAAlE,UAAAwE,YAAA,SAAYC,GACNrG,KAAK2B,OAAO2E,WAChBtG,KAAKuG,WACLF,EAAMG,aAAaC,QAAQ,OAAQ,eACnCJ,EAAMG,aAAaC,QAAQ,KAAMzG,KAAKsF,cAAcxC,IAGpD9C,KAAK0G,KAAKC,SAAW,CACnBC,KAAM5G,KAAK4G,KACXC,KAAM7G,KAAK6G,KACXC,SAAU9G,QAKd8F,EAAAlE,UAAAmF,UAAA,SAAUV,GACRrG,KAAKgH,YA4CPlB,EAAAlE,UAAAqF,KAAA,SAAKP,EAAMQ,EAAeC,GACxBnH,KAAK0G,KAAOA,EACZ1G,KAAKkH,cAAgBA,EACrBlH,KAAKmH,YAAcA,GAGrBrB,EAAAlE,UAAAwF,cAAA,WACE,OAAO,GAGTtB,EAAAlE,UAAAyF,QAAA,SAAQC,EAAmCjG,GACzC,OAAO,GAGTyE,EAAAlE,UAAA2F,oBAAA,SAAoBC,EAAkBC,GACpC,OAAO,GAGH3B,EAAAlE,UAAA8F,SAAA,SAASb,uFAEff,EAAAlE,UAAA+F,wBAAA,SAAwB/G,GACtB,MAAO,CAAC,QAAS,OAAQ,QAAS,UAGpCkF,EAAAlE,UAAAqD,SAAA,aAIAa,EAAAlE,UAAAsD,gBAAA,WACE,IAAKlF,KAAKsF,cACR,KAAM,4FAIRtF,KAAKsF,cAAcsC,UAAUC,IAAI,4BACjC7H,KAAKsF,cAAcC,aAAa,YAAa,QAEzCvF,KAAK8H,eACP9H,KAAK+H,aAAa/H,KAAK8H,eAIzB9H,KAAKsF,cAAcxC,GAAK9C,KAAK8C,GAE7B9C,KAAK+F,SAASiC,QAGhBnH,OAAA2D,eAAIsB,EAAAlE,UAAA,KAAE,KAAN,WAIE,OAHgB,MAAZ5B,KAAKiI,MACPjI,KAAKiI,IAAM,IAAMC,KAAKC,OAEjBnI,KAAKiI,qCAGdpH,OAAA2D,eAAIsB,EAAAlE,UAAA,kBAAe,KAAnB,WACE,OAAO5B,KAAKiG,kDAQRH,EAAAlE,UAAAwG,SAAA,SAASC,EAAkCC,mGAE5B,MAAA,CAAA,EAAMtI,KAAK2B,OAAO4G,WAAWF,WAahD,OAbIG,EAAe7F,EAAApD,OACnBS,KAAK2B,OAAO8G,YAAYD,IACpBF,MAAAA,OAAO,EAAPA,EAASI,SACX1I,KAAK2I,kBAAkBH,EAAa1B,SAAUwB,MAAAA,OAAO,EAAPA,EAASM,OAGvD5I,KAAK6I,WAAWL,EAAa1B,UAG/B9G,KAAK2B,OAAOS,KAAK0G,QAAQN,EAAa1B,UAEtC9G,KAAK2B,OAAOyB,WAEZ,CAAA,EAAOoF,EAAa1B,kBAQtBhB,EAAAlE,UAAAyB,QAAA,SAAQ0F,EAA2BC,GAEjC,QAFM,IAAAD,IAAAA,GAAA,QAA2B,IAAAC,IAAAA,GAAA,IAE5BA,GAAkBhJ,KAAKoH,gBAAiB,CAC3CpH,KAAK2B,OAAO2G,QAAQW,UAAUC,kBAC9BlJ,KAAK2B,OAAO2G,QAAQW,UAAUC,iBAAiBlJ,MAE/C,IAAImJ,OAAW,EAYf,OAXInJ,KAAKoJ,UACPD,EAAcnJ,KAAKoJ,QAAQC,YAAYrJ,OAGzCA,KAAKsJ,SAASH,EAAaJ,GAE3B/I,KAAK2B,OAAOyB,WAEZpD,KAAK2B,OAAO2G,QAAQW,UAAUM,iBAC9BvJ,KAAK2B,OAAO2G,QAAQW,UAAUM,gBAAgBvJ,OAEvC,EAET,OAAO,GAST8F,EAAAlE,UAAAyH,YAAA,SAAYG,GACV,IAAKxJ,KAAKyJ,SACR,OAAQ,EAEV,IAAMtI,EAAInB,KAAKyJ,SAASC,WAAU,SAAAzG,GAAS,OAAAA,EAAMH,IAAM0G,EAAc1G,MAKrE,OAJI3B,GAAK,GACPnB,KAAKyJ,SAASE,OAAOxI,EAAG,GAGnBA,GAQT2E,EAAAlE,UAAAgI,UAAA,SAAUC,EAAqCC,QAAA,IAAAA,IAAAA,GAAA,IACzC9J,KAAK+J,QAAWD,GAIpB9J,KAAKoJ,QAAUS,GACV7J,KAAKoJ,SAAWpJ,KAAKqF,QACxBrF,KAAKqF,MAAMhC,UACXrD,KAAKqF,MAAQ,OANb2E,QAAQC,KAAK,8EAejBnE,EAAAlE,UAAAsI,gBAAA,WACElK,KAAKsF,cAAc6E,gBAAgBpG,IAOrC+B,EAAAlE,UAAAwI,cAAA,SAAcC,GACZrK,KAAKsF,cAAcC,aAAaxB,EAA2BsG,EAASC,gBAMtExE,EAAAlE,UAAA2I,cAAA,WACE,OAAQvK,KAAK+J,QAOfjE,EAAAlE,UAAA4I,YAAA,SAAYC,GACV,YADU,IAAAA,IAAAA,EAAA,GACHzK,KAAKyJ,UAAYzJ,KAAKyJ,SAAShJ,QAAUgK,GAIlD5J,OAAA2D,eAAIsB,EAAAlE,UAAA,WAAQ,KAAZ,WACE,OAAO5B,KAAKmG,2CAIdtF,OAAA2D,eAAIsB,EAAAlE,UAAA,SAAM,KAAV,WACE,OAAO5B,KAAKoJ,yCAOdtD,EAAAlE,UAAA8I,iBAAA,SAAiBnH,GACf,IAAMoH,EAAmB3K,KAAKsF,cAAcsF,wBAAwBC,MAEpE,IAAK7K,KAAKwK,cACR,OAAOxK,KAAKsF,cAAcsF,wBAAwBC,MAGpD,IAAIC,EAAa9K,KAAKmG,UAAU4E,QAAO,SAACC,EAAgB/H,GACtD,OAAO+H,EAAkB/H,EAAMyH,iBAAiBnH,KAC/C,GAIH,OAFAuH,GAAcvH,GAAWvD,KAAKmG,UAAU1F,OAAS,GAE1CoE,KAAKoG,IAAIN,EAAkBG,IAMpChF,EAAAlE,UAAAsJ,SAAA,WACE,OAAOlL,KAAKkG,WAQdJ,EAAAlE,UAAAuJ,eAAA,SAAeC,GACb,IAAIC,EAAarL,KAAKsF,cAAcsF,wBAEpC,MAAO,CACLU,OAAQtL,KAAKiG,iBAAiB,GAAKoF,EAAWE,SAAUH,MAAAA,OAAU,EAAVA,EAAYI,MAAO,GAC3EC,KAAMzL,KAAKiG,iBAAiB,KAAMmF,MAAAA,OAAU,EAAVA,EAAYK,OAAQ,GACtDF,OAAQF,EAAWE,OACnBV,MAAOQ,EAAWR,MAClBa,MAAO1L,KAAKiG,iBAAiB,GAAKoF,EAAWR,QAASO,MAAAA,OAAU,EAAVA,EAAYK,OAAQ,GAC1ED,IAAKxL,KAAKiG,iBAAiB,KAAMmF,MAAAA,OAAU,EAAVA,EAAYI,MAAO,KAOxD1F,EAAAlE,UAAAC,OAAA,WACE,MAAO,CACLiB,GAAI9C,KAAK8C,GACT8D,KAAM5G,KAAK4G,KACXC,KAAM7G,KAAK6G,KACX4C,SAAUzJ,KAAKwK,cAAgBxK,KAAKmG,UAAUwF,KAAI,SAAA1I,GAChD,OAAOA,EAAMpB,YACV,KAKThB,OAAA2D,eAAIsB,EAAAlE,UAAA,gBAAa,KAAjB,iBACE,OAAgB,QAAhBO,EAAOnC,KAAK4L,YAAI,IAAAzJ,OAAA,EAAAA,EAAEmD,+CAGpBQ,EAAAlE,UAAAiK,MAAA,SAAM/I,GACJ9C,KAAKiI,IAAMnF,GAGbgD,EAAAlE,UAAAmG,aAAA,SAAatD,EAAeqH,GAE1B,QAF0B,IAAAA,IAAAA,GAAA,IAErB9L,KAAK4L,KAIR,OAHA5B,QAAQC,KAAK,gDAEbjK,KAAK8H,cAAaxG,EAAOmD,IAI3B,IAAIsH,EAAYlH,KAAKoG,IAAIxG,EAAI,IAAMqH,EAAe9L,KAAKsF,cAAc0G,YAAc,EAAI,GAAI,GACvFC,EAAYpH,KAAKoG,IAAIxG,EAAI,IAAMqH,EAAe9L,KAAKsF,cAAc4G,aAAe,EAAI,GAAI,GAE5FlM,KAAKsF,cAAc6G,MAAMV,KAAUM,EAAS,KAC5C/L,KAAKsF,cAAc6G,MAAMX,IAASS,EAAS,KAE3CjM,KAAKiG,iBAAmB,CAAC8F,EAAWE,IAGtCnG,EAAAlE,UAAAiH,WAAA,SAAWuD,GACT,IAAIC,EAAgB,KAKpB,GAJID,EAAShD,UACXiD,EAAgBD,EAAShD,QAAQC,YAAY+C,IAG3CpM,KAAKwK,cACP,GAAI4B,EAAS5B,cAAe,CAE1B,IAAI8B,EAAoBF,EAASG,sBACjC,IAAKD,EAGH,OAFAF,EAAShD,QAAQT,kBAAkByD,EAAUC,GAC7CrC,QAAQ3I,MAAM,sDACP,EAGTiL,EAAkBE,YAAYxM,KAAKmG,UAAUsG,cAI7CL,EAASI,YAAYxM,KAAKmG,UAAUsG,SAMxC,OADAzM,KAAKwM,YAAY,CAACJ,KACX,GAGTtG,EAAAlE,UAAA+G,kBAAA,SAAkB1F,EAAiC2F,GAC7C3F,EAAMmG,SACRnG,EAAMmG,QAAQC,YAAYpG,GAGvBjD,KAAKyJ,WACRzJ,KAAKmG,UAAY,IAEN,MAATyC,EACF5I,KAAKyJ,SAAS/I,KAAKuC,GAGnBjD,KAAKyJ,SAASE,OAAOf,EAAO,EAAG3F,GAIjCA,EAAM2G,UAAU5J,MAAM,IAGxB8F,EAAAlE,UAAA8K,WAAA,SAAW/H,EAAiBC,GACrB5E,KAAKqF,OACRrF,KAAK2M,cAEP3M,KAAKqF,MAAMyB,SAASuD,SAAW,CAC7B1F,MAAOA,EACPC,IAAKA,IAODkB,EAAAlE,UAAA0H,SAAA,SAASH,EAAaJ,GAW5B,QAX4B,IAAAA,IAAAA,GAAA,GAE5B/I,KAAK4M,QAAQvJ,UAGbrD,KAAK2B,OAAOS,KAAKyK,WAAW7M,MAExBA,KAAKuK,kBACPvK,KAAK2B,OAAOS,KAAKC,SAAW,MAG1BrC,KAAKwK,cAAe,CAGtB,GAAIxK,KAAKuK,kBAEFxB,EAAW,CAEd,IAAI+D,EAAU9M,KAAKmG,UAAU,GAM7B,GAJAnG,KAAK2B,OAAOS,KAAKC,SAAWyK,EAC5BA,EAAQlD,UAAU,MAAM,GAGpB5J,KAAKwK,YAAY,GACnB,IAAK,IAAIrJ,EAAI,EAAGA,EAAInB,KAAKmG,UAAU1F,OAAQU,IAAK,EAC1C8B,EAAQjD,KAAKmG,UAAUhF,IACrByI,UAAUkD,GAAS,GACzBA,EAAQ3G,UAAUzF,KAAKuC,IAQ/B,IAAIxC,EAAST,KAAKmG,UAAU1F,OAC5B,IAASU,EAAI,EAAGA,EAAIV,EAAQU,IAAK,CAC/B,IAAI8B,EAAQjD,KAAKmG,UAAUhF,GACvB4H,EACD9F,EAAmCqG,SAAS,MAAM,GAI1CtJ,KAAKoJ,UACdpJ,KAAKoJ,QAAQjD,UAAUwD,OAAOxI,EAAIgI,EAAa,EAAGlG,GAClDA,EAAM2G,UAAU5J,KAAKoJ,SAAS,IAGlCpJ,KAAKwM,YAAY,IAEnBxM,KAAKoJ,QAAU,MAGTtD,EAAAlE,UAAA+K,YAAA,WACN,IAAMI,EAAU/M,KAAKmH,YAAY6F,wBAAwBhJ,GACzDhE,KAAKqF,MAAQrF,KAAKkH,cAAc+F,gBAAgBF,GAChD/M,KAAKsF,cAAc4H,cAAcC,YAAYnN,KAAKqF,MAAM+H,SAAS9H,gBAG3DQ,EAAAlE,UAAA2E,SAAA,WACNvG,KAAKkG,WAAY,EACjBlG,KAAKsF,cAAc6G,MAAMlI,QAAU,KAE/BjE,KAAKqF,OACPrF,KAAKqF,MAAMyB,SAAS3B,YAGlBnF,KAAKwK,eACPxK,KAAKmG,UAAUkH,SAAQ,SAAApK,GACrBA,EAAMsD,eAKJT,EAAAlE,UAAAoF,SAAA,WACNhH,KAAKkG,WAAY,EAEblG,KAAKqF,OACPrF,KAAKqF,MAAMyB,SAAS1B,YAGtBpF,KAAKsF,cAAc6G,MAAMlI,QAAU,IAC/BjE,KAAKwK,eACPxK,KAAKmG,UAAUkH,SAAQ,SAAApK,GACrBA,EAAM+D,eAKJlB,EAAAlE,UAAA2K,oBAAA,WAEN,OAAIvM,KAAKwK,YAAY,GACZ,KAGAxK,KAAKwK,cACLxK,KAAKmG,UAAU,GAAGoG,sBAGfvM,MAGN8F,EAAAlE,UAAA4K,YAAA,SAAY/C,GAAZ,IAAA6D,EAAAtN,KACNA,KAAKmG,UAAYsD,EACjBzJ,KAAKyJ,SAAS4D,SAAQ,SAAApK,GACpBA,EAAM2G,UAAU0D,GAAM,gCA5f3B9H,EAAAA,UAASC,KAAA,CAAC,CACTC,SAAU,oBACVC,SAAA,6QAEA4H,cAAeC,EAAAA,kBAAkBC,+nEAIhCC,EAAAA,aAAYjI,KAAA,CAAC,YAAa,CAAC,8BAe3BiI,EAAAA,aAAYjI,KAAA,CAAC,UAAW,CAAC,yBAMzBG,EAAAA,UAASH,KAAA,CAAC,+BAGVI,EAAAA,oBAGAA,EAAAA,sBAGAA,EAAAA,uBAGAA,EAAAA,wBAGA8H,EAAAA,gCAGA9H,EAAAA,0BCxDC,SAAA+H,IAFQ5N,KAAA6N,WAAoC,GAGxC7N,KAAK8N,SAAW,IAAIrM,EAAAA,YAAY6B,eAGpCsK,EAAAhM,UAAAmM,WAAA,SAAWzF,GACPtI,KAAK8N,SAAW9N,KAAKgO,gBAAgB1F,IAGzCsF,EAAAhM,UAAAqM,aAAA,SAAahF,GACTjJ,KAAK6N,WAAa5E,GAGtBpI,OAAA2D,eAAIoJ,EAAAhM,UAAA,UAAO,KAAX,WACI,OAAO5B,KAAK8N,0CAGhBjN,OAAA2D,eAAIoJ,EAAAhM,UAAA,YAAS,KAAb,WACI,OAAO5B,KAAK6N,4CAGRD,EAAAhM,UAAAoM,gBAAA,SAAgB1F,GACpB,IAAM4F,EAAc,IAAIzM,EAAAA,YAAY6B,QAUpC,OARAgF,EAAOzH,OAAAsN,OAAAtN,OAAAsN,OAAA,GACFD,GACA5F,IAGG/E,QAAUsB,KAAKoG,IAAI3C,EAAQ/E,QAAS,KAAO,GACnD+E,EAAQ9E,oBAAsBqB,KAAKoG,IAAI3C,EAAQ9E,oBAAqB,IAAM,GAEnE8E,4BArCd8F,EAAAA,oECiBG,SAAAC,EACY/F,GAAAtI,KAAAsI,QAAAA,EAJJtI,KAAAsO,MAAgB,EAChBtO,KAAAuO,mBAAqB,YAQtBF,EAAAzM,UAAAqF,KAAA,SAAKC,GACRlH,KAAKkH,cAAgBA,GAGlBmH,EAAAzM,UAAA4M,WAAA,SAAW5N,EAA8C6N,GAC5DzO,KAAK0O,0BAA0BvB,YAAavM,EAAKwM,SAAsB,eACvEpN,KAAK2O,gBAAgB/N,EAAKkG,SAAU2H,IAGjCJ,EAAAzM,UAAAgN,cAAA,SAAchO,EAA8C6N,GAC/DzO,KAAK0O,0BAA0BvB,YAAavM,EAAKwM,SAAsB,gBAGpEiB,EAAAzM,UAAAiN,eAAA,SAAejO,EAAgC6N,GAA/C,IAAAnB,EAAAtN,KACC8O,EAAa9O,KAAK+O,cAAcN,GAEpCK,EAAaA,EAAWnD,KAAI,SAAAqD,GAAS,OAAAA,EAAQ1B,EAAKgB,SAClD1N,EAAKmH,aAAa+G,GAAY,IAG1BT,EAAAzM,UAAAqN,WAAA,WACJ,OAAOjP,KAAKsI,QAAQA,QAAQ/E,SAGxB8K,EAAAzM,UAAAsN,gBAAA,SAAgBC,EAAoCC,EAA4BhE,GAAhF,IAAAkC,EAAAtN,KAGJ,GAAKmP,EAAS3E,cAAd,CAKA,IAAM6E,EAAaD,EAAS9D,OAASF,EAAWI,IAAMxL,KAAKsO,MAAStO,KAAKiP,aAEnEK,EAAYF,EAASvE,MAAQ7K,KAAKsO,MAElCiB,EAAeH,EAAS3D,KAAOL,EAAWK,KAAS6D,EAAY,EAIjEE,EAAkB,GAClBC,EAAiB,EAErBN,EAAS1F,SAAS4D,SAAQ,SAAApK,GACtB,IAAIyM,EAAkBzM,EAAMyH,iBAAiB4C,EAAK2B,cAClDS,GAAoCpC,EAAKgB,MACzCkB,EAAgBvM,EAAMqC,cAAcxC,IAAM4M,EAE1CD,GAAkBC,KAItBD,IAAmBN,EAAS1F,SAAShJ,OAAS,GAAKT,KAAKiP,aAGxD,IAAIU,EAAYJ,EAAeE,EAAiB,EAGhDE,EAAY9K,KAAKoG,IAAI,EAAG0E,GAExBR,EAAS1F,SAAS4D,SAAQ,SAAApK,GAEtB,IAAI2M,EAAcJ,EAAgBvM,EAAMqC,cAAcxC,IAElD+M,EAAYF,EAAaC,EAAc,EAAM3M,EAAMqC,cAAc0G,YAAc,EAGnF/I,EAAM8E,aAAa,CAAC8H,EAAWR,IAE/B,IAAMS,EAAmB7M,EAAMkI,eAAeC,GAExCN,EAAagF,EAAiBjF,MAAQyC,EAAKgB,MAEjDrL,EAAMyJ,WACF,CAAC6C,EAAcH,EAAS9D,OAASF,EAAWI,IAAM8B,EAAKgB,OACvD,CAACwB,EAAiBrE,KAAOX,EAAa,EAAIM,EAAWK,KAAMqE,EAAiBtE,IAAMJ,EAAWI,MAGjG8B,EAAK4B,gBAAgBjM,EAAO6M,EAAkB1E,GAC9CuE,GAAaC,EAActC,EAAK2B,kBAMjCZ,EAAAzM,UAAAsB,OAAA,SAAOd,EAAkBe,EAAkB4M,aAC9C,QAD8C,IAAAA,IAAAA,GAAA,GACzC3N,EAAK4N,UAAV,EAY0B,QAA1BrN,EAAI3C,KAAKsI,QAAQW,iBAAS,IAAAtG,OAAA,EAAAA,EAAEsN,eACxBjQ,KAAKsI,QAAQW,UAAUgH,eAG3B,IAAM7E,EAAapL,KAAK0O,0BAA0B9D,wBAC9CzH,GAEAnD,KAAK2O,gBAAgBvM,EAAKC,SAAU,MAExCrC,KAAKkP,gBAAgB9M,EAAKC,SAAUD,EAAKC,SAAS8I,eAAeC,GAAaA,GAEzE2E,GAA2D,aAAnC/P,KAAKsI,QAAQA,QAAQ1E,KAAKC,MACnD7D,KAAKkQ,iBAAiB9N,EAAMgJ,IAGN,QAA1B+E,EAAInQ,KAAKsI,QAAQW,iBAAS,IAAAkH,OAAA,EAAAA,EAAEC,cACxBpQ,KAAKsI,QAAQW,UAAUmH,kBA3BgB,aAAnCpQ,KAAKsI,QAAQA,QAAQ1E,KAAKC,OAC1B7D,KAAKqQ,yBAGqB,QAA1BlO,EAAInC,KAAKsI,QAAQW,iBAAS,IAAA9G,OAAA,EAAAA,EAAEiO,cACxBpQ,KAAKsI,QAAQW,UAAUmH,gBA0B/B/B,EAAAzM,UAAAyO,sBAAA,WAEJ,GAAIrQ,KAAKkH,cAAe,CACpB,IAAMoJ,EAAgBtQ,KAAK0O,0BAC3B4B,EAAcnE,MAAMoE,SAAW,KAC/BD,EAAcnE,MAAMqE,UAAY,OAKhCnC,EAAAzM,UAAA6O,yBAAA,SAAyBC,EAAsBC,EAAsClJ,GAEzF,IAAKkJ,EAAWpJ,oBAAoBmJ,EAAYjJ,GAC5C,MAAO,WAGX,IAAMmJ,EAAWD,EAAWrL,cAAcsF,wBAEpCiG,EAAcD,EAAStF,OAASsF,EAASrF,OAAS,EAClDuF,EAAcF,EAASnF,KAAOmF,EAAS/F,MAAQ,EAE/CkG,EAAQL,EAAW,GAAKG,EACxBG,EAAQN,EAAW,GAAKI,EAExBG,EAAepM,KAAKC,IAAIiM,GACxBG,EAAerM,KAAKC,IAAIkM,GAGxBG,EAAWtM,KAAKuM,KAAKH,EAAeA,EAAeC,EAAeA,GAGpEG,EAA4C,KA+BhD,OA7BIF,GAJoBP,EAASrF,OAASqF,EAAS/F,OAAS,IAKpDsG,EAAWnR,KAAKsI,QAAQA,QAAQ9E,sBAEhC6N,EAAS,YAGTJ,EAAeC,EACfG,EAAS,CACLzQ,KAAM+P,EACNtG,SAAU0G,EAAQ,EAAI,QAAU,QAChCO,UAAWL,GAGTjR,KAAKsI,QAAQA,QAAQ7E,cAAiBkN,EAAWpG,kBACvD8G,EAAS,CACLzQ,KAAM+P,EACNtG,SAAU2G,EAAQ,EAAI,QAAU,OAChCM,UAAWJ,KAKnBG,GAAqB,aAAXA,IACLV,EAAWhJ,wBAAwBF,GAAY8J,SAASF,EAAOhH,YAEhEgH,EAAS,OAIVA,GAGHhD,EAAAzM,UAAAsO,iBAAA,SAAiB9N,EAAkBgJ,GACvC,IAAIoG,EAAW,EACXC,EAAY,EAGhBrP,EAAKW,MAAMsK,SACP,SAAAqE,GACI,IAAIC,EAAOD,EAAIvG,eAAeC,GAC9BoG,EAAW3M,KAAKoG,IAAI0G,EAAKjG,MAAO8F,GAChCC,EAAY5M,KAAKoG,IAAI0G,EAAKrG,OAAQmG,MAI1C,IAAMG,EAAiB,IACjBC,EAAYzG,EAAWP,OAAS2G,EAAWpG,EAAWK,MAC5D,GAAIoG,EAAYD,EAAgB,CAC5B,IAAIE,EAAYF,EACbC,EAAY,IACXC,GAAajN,KAAKC,IAAI+M,IAE1B7R,KAAK0O,0BAA0BvC,MAAMoE,SAAcnF,EAAWP,MAAQiH,EAAS,KAC3E9R,KAAKsI,QAAQA,QAAQ3E,gBACrB3D,KAAKkD,OAAOd,GAAM,GAAM,QAEzB,GAAGyP,EAAYD,EAAgB,CAClC,IAAInC,EAAiBzP,KAAK+R,kBAAkB3P,GACzCpC,KAAKgS,kBACJhS,KAAK0O,0BAA0BvC,MAAMoE,SAAcd,EAAiBmC,EAAc,KAC9E5R,KAAKsI,QAAQA,QAAQ3E,gBACrB3D,KAAKkD,OAAOd,GAAM,GAAM,IAEtBpC,KAAK0O,0BAA0BvC,MAAMoE,WAE3CvQ,KAAK0O,0BAA0BvC,MAAMoE,SAAW,KAC5CvQ,KAAKsI,QAAQA,QAAQ3E,gBACrB3D,KAAKkD,OAAOd,GAAM,GAAM,IAKpC,IACM6P,EAAa7G,EAAWG,QAAUkG,EAAYrG,EAAWI,KAC/D,GAAIyG,EAFoB,GAEU,CAC9B,IAAIC,EAHgB,GAIjBD,EAAa,IACZC,GAAcrN,KAAKC,IAAImN,IAE3BjS,KAAK0O,0BAA0BvC,MAAMqE,UAAepF,EAAWG,OAAS2G,EAAU,UAC/E,GAAGD,EARc,GASpB,GAAGjS,KAAKgS,iBAAkB,CACtB,IAAIG,EAAeF,EAVH,GAWhBjS,KAAK0O,0BAA0BvC,MAAMqE,UAAepF,EAAWG,OAAS4G,EAAY,UAC9EnS,KAAK0O,0BAA0BvC,MAAMqE,YAE3CxQ,KAAK0O,0BAA0BvC,MAAMqE,UAAY,OAKrDnC,EAAAzM,UAAAmQ,kBAAA,SAAkB3P,GAAlB,IAAAkL,EAAAtN,KACAyP,EAAiB,EACfH,EAAYlN,EAAKC,SAAS8I,iBAAiBN,MAAQ7K,KAAKsO,MAO9D,OANAlM,EAAKC,SAASoH,SAAS4D,SAAQ,SAAApK,GAC3B,IAAIyM,EAAkBzM,EAAMyH,iBAAiB4C,EAAK2B,cAClDQ,GAAkBC,EAAkBpC,EAAKgB,SAE7CmB,IAAmBrN,EAAKC,SAASoH,SAAShJ,OAAS,GAAKT,KAAKiP,aAEtDpK,KAAKoG,IAAIwE,EAAgBH,IAG5BjB,EAAAzM,UAAAwQ,sBAAA,SAAsBzL,EAA4BN,EAAkBtD,GAKxE,IAJA,IAAMsP,EAAQ,CAAChM,EAAMiM,QAASjM,EAAMkM,SAEhCC,EAA2B,KAEtBrR,EAAI,EAAGA,EAAI4B,EAAMtC,OAAQU,IAAK,CAEnC,IAAMP,EAAOmC,EAAM5B,GAEnB,IAAIP,EAAKsK,WAAT,CAIA,IAAMb,EAAWrK,KAAKyQ,yBAAyB4B,EAAOzR,EAAM+F,GAC5D,GAAI0D,EAAU,CACV,GAAgB,YAAZA,EAAwB,CACxBmI,EAAY,KACZ,OAGkB,MAAbA,GAAqBA,EAAUlB,UAAYjH,EAASiH,aACzDkB,EAAYnI,KAKxB,OAAOmI,GAGJnE,EAAAzM,UAAA6Q,uBAAA,SAAuB9L,EAA4BN,EAAkBtD,GACxE,GAAKA,GAAyB,GAAhBA,EAAMtC,OAApB,CAIA,IAAI+R,EAA2BxS,KAAKoS,sBAAsBzL,EAAUN,EAAOtD,GAU3E,GAPAA,EAAMsK,SAAQ,SAAAzM,GACO,MAAb4R,GAAqB5R,EAAK0E,cAAcxC,KAAO0P,EAAU5R,KAAK0E,cAAcxC,IAE5ElC,EAAKsJ,qBAIRsI,EAML,OAFAA,EAAU5R,KAAKwJ,cAAcoI,EAAUnI,UAEhC,CACHzJ,KAAM4R,EAAU5R,KAChByJ,SAAUmI,EAAUnI,YAIrBgE,EAAAzM,UAAA8Q,UAAA,SAAU/L,KAKV0H,EAAAzM,UAAA+Q,uBAAA,SAAuB5P,GAC1BA,EAAMsK,SACF,SAAAzM,GAAQ,OAAAA,EAAKsJ,sBAIbmE,EAAAzM,UAAA+M,gBAAA,SAAgB/N,EAAgC6N,GAEpD,GAAKA,EAML,OAAQzO,KAAKsI,QAAQA,QAAQ5E,cACzB,IAAK,SACD,IAAMkP,EAAe5S,KAAK6S,0BAE1B,YADAjS,EAAKmH,aAAa6K,GAAc,GAEpC,IAAK,aACKE,EAAY9S,KAAK+S,2BAA2BnS,EAAK0E,eAEvD,YADA1E,EAAKmH,aAAa+K,GAAW,GAEjC,QACI,IAAMhE,EAAa9O,KAAK+O,cAAcN,GAEtC,YADA7N,EAAKmH,aAAa+G,GAAY,OAjBtC,CACI,IAAMgE,EAAY9S,KAAK+S,2BAA2BnS,EAAK0E,eACvD1E,EAAKmH,aAAa+K,GAAW,KAoB7BzE,EAAAzM,UAAAmN,cAAA,SAAcN,GAClB,IAAMrD,EAAapL,KAAK0O,0BAA0B9D,wBAElD,MAAO,CACH6D,EAAU6D,QAAUlH,EAAWK,KAC/BgD,EAAU8D,QAAUnH,EAAWI,MAI/B6C,EAAAzM,UAAAmR,2BAAA,SAA2BC,GAC/B,IAAM5H,EAAapL,KAAK0O,0BAA0B9D,wBAE5CqI,EADoBD,EAAgBpI,wBAAwBW,OAC/B,EAAIvL,KAAKsI,QAAQA,QAAQ/E,QACtD2P,EAAkC,KAAlB,EAAIlT,KAAKsO,OAE/B,MAAO,CACHlD,EAAWP,OAAsB,EAAb7K,KAAKsO,OACzB2E,EAASC,IAIT7E,EAAAzM,UAAAiR,wBAAA,WACJ,IAAMzH,EAAapL,KAAK0O,0BAA0B9D,wBAClD,MAAO,CACHQ,EAAWP,MAAQ,EACnBO,EAAWG,OAAS,IAIpB8C,EAAAzM,UAAA8M,wBAAA,WAGJ,OAFe1O,KAAKkH,cAAciM,QAAQ7N,cACf8N,uBAAuBrP,GAAgCsP,KAAK,IAInFhF,EAAAzM,UAAAoQ,eAAA,WACJ,GAAIhS,KAAKkH,cAAe,CACpB,IAAMoJ,EAAiBtQ,KAAKkH,cAAciM,QAAQ7N,cAA8B4H,cAChF,GAAIoD,EACA,OAAOA,EAAc1I,UAAU0L,SAAS,4BAGhD,OAAO,GAGJjF,EAAAzM,UAAA2R,WAAA,SAAWnR,GACdpC,KAAKwT,SAASpR,EAAM,IAGjBiM,EAAAzM,UAAA6R,QAAA,SAAQrR,EAAkBxB,GAC7B,IAAM8S,EAAW1T,KAAKsO,OAAStO,KAAKsO,MAAQ1N,GAAQZ,KAAKsI,QAAQA,QAAQ1E,KAAKE,aAC9E9D,KAAKwT,SAASpR,EAAMsR,IAIjBrF,EAAAzM,UAAA+R,UAAA,SAAUvR,EAAkBxB,GAC/B,IAAM8S,EAAW1T,KAAKsO,OAAStO,KAAKsO,MAAQ1N,GAAQZ,KAAKsI,QAAQA,QAAQ1E,KAAKE,aAC9E9D,KAAKwT,SAASpR,EAAMsR,IAGjBrF,EAAAzM,UAAA4R,SAAA,SAASpR,EAAkBwR,SACxBC,EAAkB,EAAED,EAAa,IAAG,IAEpCE,EAAgB9T,KAAK0O,0BAE3BoF,EAAc3H,MAAM4H,UAAY,SAASH,EAAU,IACnDE,EAAc3H,MAAMqE,UAAYqD,EAChCC,EAAc3H,MAAMoE,SAAWsD,EAC/BC,EAAc3H,MAAM6H,gBAAkB,WACtCF,EAAclM,UAAUC,IAAI,WAE5B7H,KAAKsO,MAAQsF,EACb5T,KAAKkD,OAAOd,GAAM,IAEO,QAAzBD,EAAGnC,KAAKsI,QAAQW,iBAAS,IAAA9G,OAAA,EAAAA,EAAE8R,aACvBjU,KAAKsI,QAAQW,UAAUgL,WAAWjU,KAAKsO,OAG3CtO,KAAKuO,oBAAsB2F,aAAalU,KAAKuO,oBAC7CvO,KAAKuO,mBAAqB4F,YAAW,WACjCL,EAAclM,UAAUwM,OAAO,aAChC,+BAvbVhG,EAAAA,sDARQR,sBCOL,SAAAyG,YAGOA,EAAAzS,UAAA0S,YAAA,SAAYC,GACfvU,KAAK2G,SAAW4N,GAGbF,EAAAzS,UAAA4S,YAAA,WACH,OAAOxU,KAAK2G,8HAfnByH,EAAAA,WAAU3I,KAAA,CAAC,CACRgP,WAAY,kECIZ,SAAAC,IAFQ1U,KAAA2U,SAAW,IAAIC,WAWvBF,EAAA9S,UAAAiT,aAAA,SAAajO,EAAchG,GACvBZ,KAAK2U,SAASG,IAAIlO,EAAMhG,IAG5B8T,EAAA9S,UAAAmT,YAAA,SAAYnO,GACR,OAAO5G,KAAK2U,SAASK,IAAIpO,wHArBhCwH,EAAAA,WAAU3I,KAAA,CAAC,CACRgP,WAAY,kECWd,SAAAQ,EAAoBC,EAA4DP,GAA5D3U,KAAAkV,yBAAAA,EAA4DlV,KAAA2U,SAAAA,SAIzEM,EAAArT,UAAAqF,KAAA,SAAKC,GACVlH,KAAKkH,cAAgBA,GAGhB+N,EAAArT,UAAAuT,mBAAA,SAAmBrS,EAAY8D,EAAcC,EAAWlF,GAC7D,IACIiL,EADAwI,EAAepV,KAAK2U,SAASI,YAAYnO,GAE7C,KAAIwO,aAAwBC,EAAAA,aAAeD,aAAwBE,EAAAA,MAQjE,KAAM,kDAAoD1O,EAI5D,OAXEgG,EAAU5M,KAAKc,OAAO,CACpB6E,SAAUyP,EACVxO,KAAMA,EACNC,KAAMA,GACLlF,IAMGmF,SAAS+E,MAAM/I,GAChB8J,GAGFqI,EAAArT,UAAAd,OAAA,SAAOyU,EAAsC5T,GAClD,IAAI6G,EAEJ,GAAI+M,EAAY5P,oBAAoB0P,EAAAA,YAAa,CAC/C,IAAMtI,EAAU/M,KAAKkV,yBAAyBlI,wBAAwBlH,IACtE0C,EAAexI,KAAKkH,cAAc+F,gBAA0CF,IAC/DjG,SAAS0O,gBAAkBD,EAAY5P,aAGjD,CACGoH,EAAU/M,KAAKkV,yBAAyBlI,wBAAwBuI,EAAY5P,UAClF6C,EAAexI,KAAKkH,cAAc+F,gBAAqBF,GAczD,OAXAvE,EAAa1B,SAASD,KAAO9E,KAAKU,MAAMV,KAAKC,UAAUuT,EAAY1O,OACnE2B,EAAa1B,SAASF,KAAO2O,EAAY3O,KACzC4B,EAAa1B,SAASnF,OAASA,EAC/B6G,EAAa1B,SAAS8F,QAAUpE,EAChCA,EAAa1B,SAASG,KACpBuB,EAAaiN,SAAST,IAAIX,GAC1B7L,EAAaiN,SAAST,IAAIU,EAAAA,kBAC1BlN,EAAaiN,SAAST,IAAIW,EAAAA,2BAIrBnN,4BAxDV4F,EAAAA,sDAVQuH,EAAAA,gCAGAjB,qUCUTkB,EAAA,WA0BE,SAAAA,IAtBQ5V,KAAA6V,OAAqC,UAE7CD,EAAAhU,UAAAoO,QAAA,WACE,QAAShQ,KAAKqC,UAGhBuT,EAAAhU,UAAAkH,QAAA,SAAQlI,GACNZ,KAAK6V,OAAOnV,KAAKE,IAGnBgV,EAAAhU,UAAAiL,WAAA,SAAWjM,GAET,IAAIgI,EAAQ5I,KAAK6V,OAAOnM,WAAU,SAAAgI,GAAO,OAAAA,EAAI5O,IAAMlC,EAAKkC,MACpD8F,GAAS,GACX5I,KAAK6V,OAAOlM,OAAOf,EAAO,IAI9B/H,OAAA2D,eAAIoR,EAAAhU,UAAA,QAAK,KAAT,WACE,OAAO5B,KAAK6V,0CAvBhB,gBAoDE,SAAAC,EACUC,EACDzN,EACC0N,EACAC,GAHAjW,KAAA+V,KAAAA,EACD/V,KAAAsI,QAAAA,EACCtI,KAAAgW,SAAAA,EACAhW,KAAAiW,YAAAA,EArBVjW,KAAAkW,YAAsB,EAItBlW,KAAAoC,KAAmB,IAAIwT,EAEvB5V,KAAAmW,WAAqB,EAMrBnW,KAAAoW,cAAgB,CACdC,KAAM,YACNC,QAAS,uEANXzV,OAAA2D,eAAIsR,EAAAlU,UAAA,WAAQ,KAAZ,WACE,OAAO5B,KAAKmW,2CAkBPL,EAAAlU,UAAAqF,KAAA,SAAK2E,GACV5L,KAAKkH,cAAgB0E,EACrB5L,KAAKgW,SAAS/O,KAAK2E,GACnB5L,KAAKiW,YAAYhP,KAAK2E,GAGtB,IAAI2I,EAAMvU,KAAKiW,YAAYnV,OAAO,CAChC6E,SAAUG,EACVc,KAAM,GACNC,KAAM,MACL7G,MACGmB,EAAInB,KAAKkH,cAAcqP,QAAQhC,EAAIiC,UACzCxW,KAAKkH,cAAckN,OAAOjT,IAIrB2U,EAAAlU,UAAA6U,SAAA,SAASV,EAAiBjT,SAC/B9C,KAAKgW,SAASrD,uBAAuB3S,KAAKoC,KAAKW,OAE/C,IAAInC,EAAiCZ,KAAKoC,KAAKW,MAAMC,MAAK,SAAApC,GAAQ,OAAAA,EAAK0E,cAAcxC,KAAOA,KACxFzB,EAAQ,GACZ,GAAIT,EAIJ,GAAIA,EAAKyG,QAAQrH,KAAK0W,kBAAmBrV,GAAQ,CAC/C,GAAIT,EAAK2J,gBACPvK,KAAKgW,SAASnH,eAAejO,EAAMmV,GACnC/V,KAAKgW,SAAS9S,OAAOlD,KAAKoC,WAEvB,GAAIpC,KAAK0W,kBAAmB,CAC/B,IAAMC,EAAW3W,KAAK4W,cAAchW,EAAMZ,KAAK0W,mBAAmB,GAClE1W,KAAKgW,SAAS9S,OAAOlD,KAAKoC,KAAMuU,EAASE,mBAGzC7W,KAAK8W,UAAUlW,EAAMZ,KAAKoW,gBAEF,QAAtBjU,EAAAnC,KAAKsI,QAAQW,iBAAS,IAAA9G,OAAA,EAAAA,EAAE4U,cAAe/W,KAAK0W,mBAAqB9V,EAAK2J,kBACxEvK,KAAKsI,QAAQW,UAAU8N,WAAW,CAChCC,QAAQ,EACRpW,KAAMA,EACNmJ,OAAQnJ,EAAKmJ,cAKjB/J,KAAK8W,UAAUlW,EAAMS,IAOZyU,EAAAlU,UAAAqV,OAAA,SAAOlB,+GAGlB,OAFA/V,KAAKgW,SAASrD,uBAAuB3S,KAAKoC,KAAKW,OAE3C/C,KAAKoC,KAAK4N,YAAchQ,KAAK0W,mBAC/B1W,KAAKkX,UAAUlX,KAAKoW,eACpB,CAAA,IAIiB,CAAA,EAAMpW,KAAKuI,WAAWvI,KAAK+V,KAAKpP,yBAA/C6B,EAAe2O,EAAA5X,OAEb6X,EAAapX,KAAK0W,mBAAqB,KACzCrV,EAAQ,GACRmH,EAAa1B,SAASO,QAAQ+P,EAAY/V,IACvCrB,KAAKoC,KAAK4N,WAMToH,EAAWxW,KAAK2J,iBAA2C,UAAxB6M,EAAW/M,UAChDrK,KAAKgW,SAASxH,WAAWhG,EAAcuN,GAEzC/V,KAAKqX,aAAa7O,EAAc4O,KARhCpX,KAAKgW,SAASxH,WAAWhG,EAAcuN,GACvC/V,KAAKsX,QAAQ9O,EAAa1B,YAUF,QAA1B3E,EAAInC,KAAKsI,QAAQW,iBAAS,IAAA9G,OAAA,EAAAA,EAAE4U,aAC1B/W,KAAKsI,QAAQW,UAAU8N,WAAW,CAChCnW,KAAM4H,EAAa1B,SACnBkQ,QAAQ,EACRjN,OAAQvB,EAAa1B,SAASiD,WAK5B5I,EAAInB,KAAKkH,cAAcqP,QAAQ/N,EAAagO,UAClDxW,KAAKkH,cAAckN,OAAOjT,GAC1BnB,KAAKkX,UAAU7V,gBAKZyU,EAAAlU,UAAA2V,YAAA,SAAYxB,GAEjB/V,KAAKkW,YAAa,EAElBlW,KAAK0W,kBAAoB1W,KAAKgW,SAASvD,uBAAuBzS,KAAK+V,KAAKpP,SAAUoP,EAAM/V,KAAKoC,KAAKW,QAG7F+S,EAAAlU,UAAA4V,mBAAA,SAAmB1U,EAAY8D,EAAcC,GAA7C,IAAAyG,EAAAtN,KACD4M,EAAU5M,KAAKiW,YAAYd,mBAAmBrS,EAAI8D,EAAMC,EAAM7G,MAClE,OAAO,IAAIyX,SAAQ,SAACC,GAClB,IAAIC,EAAM/K,EAAQ9F,SAASf,SAAS6R,WAAU,WAAA,OAAAC,EAAAvK,OAAA,OAAA,GAAA,6CAC5CqK,EAAIG,cACJ3D,YAAW,WACTvH,EAAQ9F,SAASY,SAASb,MAE5B6Q,EAAQ9K,oBAKPkJ,EAAAlU,UAAA2G,WAAA,SAAWF,GAChB,IAAIG,EAIJ,OAFAA,EAAexI,KAAKiW,YAAYnV,OAAOuH,EAASrI,MAEzC,IAAIyX,SAAQ,SAACC,GAClB,IAAIC,EAAMnP,EAAa1B,SAASf,SAAS6R,WAAU,WACjDD,EAAIG,cACJJ,EAAQlP,MACP,SAAAnH,GAAS,OAAA2I,QAAQ3I,MAAMA,UAIvByU,EAAAlU,UAAA2R,WAAA,WACiC,aAAnCvT,KAAKsI,QAAQA,QAAQ1E,KAAKC,MAG7B7D,KAAKgW,SAASzC,WAAWvT,KAAKoC,OAGzB0T,EAAAlU,UAAA6R,QAAA,SAAQ7S,GACyB,aAAnCZ,KAAKsI,QAAQA,QAAQ1E,KAAKC,MAG7B7D,KAAKgW,SAASvC,QAAQzT,KAAKoC,KAAMxB,IAI5BkV,EAAAlU,UAAA+R,UAAA,SAAU/S,GACuB,aAAnCZ,KAAKsI,QAAQA,QAAQ1E,KAAKC,MAG7B7D,KAAKgW,SAASrC,UAAU3T,KAAKoC,KAAMxB,IAI9BkV,EAAAlU,UAAA4R,SAAA,SAASI,GACwB,aAAnC5T,KAAKsI,QAAQA,QAAQ1E,KAAKC,MAG7B7D,KAAKgW,SAASxC,SAASxT,KAAKoC,KAAMwR,IAIpCkC,EAAAlU,UAAAyV,aAAA,SAAa7O,EAAsD4O,GACjEpX,KAAKyI,YAAYD,GACjB,IAAMmO,EAAW3W,KAAK4W,cAAcpO,EAAa1B,SAAUsQ,GAC3DpX,KAAKgW,SAAS9S,OAAOlD,KAAKoC,KAAMuU,EAASE,eAG3Cf,EAAAlU,UAAA6G,YAAA,SAAYD,GACVxI,KAAKgW,SAASpH,cAAcpG,IAG9BsN,EAAAlU,UAAAwB,SAAA,SAASD,GACPnD,KAAKgW,SAAS9S,OAAOlD,KAAKoC,KAAMe,IAG5B2S,EAAAlU,UAAAU,OAAA,SAAOJ,6FACX,MAAA,CAAA,EAAMlC,KAAK+X,WAAW7V,kBAAtBiV,EAAA5X,OACAS,KAAKoD,UAAS,eAGF0S,EAAAlU,UAAAmW,WAAA,SAAWC,EAAWC,yGAClC,OAAID,EAKO,CAAA,EAAMhY,KAAKwX,mBAAmBQ,EAAKlV,GAAIkV,EAAKpR,KAAMoR,EAAKnR,OAHhE,CAAA,UAGEqR,EAAOf,EAAA5X,OACN0Y,GAKHjY,KAAKgW,SAASpH,cAAcsJ,GAC5BlY,KAAKoC,KAAK0G,QAAQoP,EAAKpR,YALvB9G,KAAKsX,QAAQY,EAAKpR,UAClB9G,KAAKgW,SAASxH,WAAW0J,EAAM,OAOxB/W,EAAI,0BAAGA,EAAI6W,EAAKvO,SAAShJ,QAC5BwC,EAAQ+U,EAAKvO,SAAStI,GACV,CAAA,EAAMnB,KAAK+X,WAAW9U,EAAOiV,EAAKpR,YAFZ,CAAA,EAAA,UAElCqR,EAAYhB,EAAA5X,OAChB2Y,EAAKpR,SAAS2C,SAAS/I,KAAKyX,GAC5BA,EAAUvO,UAAUsO,EAAKpR,UAAU,2BAJK3F,iBAO1C,MAAA,CAAA,EAAO+W,EAAKpR,kBAGNgP,EAAAlU,UAAA0V,QAAA,SAAQ1W,EAAgCkJ,GAC9C,QAD8C,IAAAA,IAAAA,GAAA,GAC1C9J,KAAKoC,KAAK4N,UAAW,CACvB,IAAKlG,EAEH,YADAE,QAAQC,KAAK,0CAKf,IAAImO,EAAUpY,KAAKoC,KAAKC,SACxBrC,KAAKoC,KAAKC,SAAWzB,EACrBA,EAAKiI,WAAWuP,QAGhBpY,KAAKoC,KAAKC,SAAWzB,EAGvBZ,KAAKoC,KAAK0G,QAAQlI,IAGZkV,EAAAlU,UAAAgV,cAAA,SAAchW,EAAgCwW,EAAoCJ,QAAA,IAAAA,IAAAA,GAAA,GAExF,IAAIL,EAAW,CACX0B,OAAO,EACPxB,cAAc,GAGlB,OAAQO,EAAW/M,UACjB,IAAK,QACHsM,EAAW3W,KAAKsY,eAAe1X,EAAMwW,EAAWxW,MAChD,MACF,IAAK,QACH+V,EAAW3W,KAAKuY,eAAe3X,EAAMwW,EAAWxW,MAChDoJ,QAAQwO,IAAI7B,EAAQrV,EAAM8V,EAAWxW,KAAK6I,WAC1C,MACF,IAAK,OACHkN,EAAW3W,KAAKyY,kBAAkB7X,EAAMwW,EAAWxW,MAAM,GACzD,MACF,IAAK,QACH+V,EAAW3W,KAAKyY,kBAAkB7X,EAAMwW,EAAWxW,MAAM,GAS7D,OAHKoW,GAAUL,EAAS0B,OACtBrY,KAAKoC,KAAK0G,QAAQlI,GAEb+V,GAGDb,EAAAlU,UAAA2W,eAAA,SAAeG,EAAmCC,GACxD,MAAO,CACLN,MAAOM,EAAW9P,WAAW6P,GAC7B7B,cAAc,IAIVf,EAAAlU,UAAA6W,kBAAA,SAAkBC,EAAmCE,EAAuCC,GAClG,QADkG,IAAAA,IAAAA,GAAA,IAC9FD,EAAY7O,OAOd,OADAC,QAAQC,KAAK,8CACN,CACLoO,OAAO,EACPxB,cAAc,GAPhB,IAAMiC,EAAgBF,EAAY7O,OAAON,SAASC,WAAU,SAAAzG,GAAS,OAAAA,EAAMqC,cAAcxC,IAAM8V,EAAYtT,cAAcxC,MAU3H,OATE8V,EAAY7O,OAAOpB,kBAAkB+P,EAASI,GAAiBD,EAAS,EAAI,IASvE,CACLR,OAAO,EACPxB,cAAc,IAIVf,EAAAlU,UAAA0W,eAAA,SAAeI,EAAmCK,SACpDlC,GAAe,EACfhN,EAAYkP,EAAUhP,OAC1B,GAAIF,EAAW,CAEDA,EAAUR,YAAY0P,GAClCL,EAAQ7P,WAAWkQ,GACnBlP,EAAUhB,WAAW6P,QAGP,QAAdvW,EAAAuW,EAAQ3O,cAAM,IAAA5H,GAAAA,EAAEkH,YAAYqP,GAC5BA,EAAQ9O,UAAU,MAAM,GAGxBmP,EAAU1P,YAAYqP,GACtB1Y,KAAKsX,QAAQoB,GAEb7B,GAAe,EAGjB,MAAO,CACLwB,OAAO,EACPxB,aAAYA,IAIRf,EAAAlU,UAAAsV,UAAA,SAAU7V,eAChB,GAA0B,QAA1Bc,EAAInC,KAAKsI,QAAQW,iBAAS,IAAA9G,OAAA,EAAAA,EAAE6W,YAAa,CACvC,IAAIjP,EAA8C,WAAf,QAAtBpH,EAAA3C,KAAK0W,yBAAiB,IAAA/T,OAAA,EAAAA,EAAE0H,UAA6C,QAAzB8F,EAAGnQ,KAAK0W,yBAAiB,IAAAvG,OAAA,EAAAA,EAAEvP,KAAKmJ,OAA+B,QAAzBkP,EAAGjZ,KAAK0W,yBAAiB,IAAAuC,OAAA,EAAAA,EAAErY,KAC1HZ,KAAKsI,QAAQW,UAAU+P,YAAY,CACjCpY,KAAOZ,KAAK+V,KAAKpP,SACjBoD,OAAQA,GAAU,KAClB1I,MAAOA,MAKLyU,EAAAlU,UAAAkV,UAAA,SAAUlW,EAAgCS,eAChD,GAA0B,QAA1Bc,EAAInC,KAAKsI,QAAQW,iBAAS,IAAA9G,OAAA,EAAAA,EAAE+W,YAAa,CACvC,IAAInP,EAA8C,WAAf,QAAtBpH,EAAA3C,KAAK0W,yBAAiB,IAAA/T,OAAA,EAAAA,EAAE0H,UAA6C,QAAzB8F,EAAGnQ,KAAK0W,yBAAiB,IAAAvG,OAAA,EAAAA,EAAEvP,KAAKmJ,OAA+B,QAAzBkP,EAAGjZ,KAAK0W,yBAAiB,IAAAuC,OAAA,EAAAA,EAAErY,KAC1HZ,KAAKsI,QAAQW,UAAUiQ,YAAY,CACjCtY,KAAM,CACJkG,SAAUlG,EACVgG,KAAMhG,EAAKgG,KACXC,KAAMjG,EAAKiG,MAEbkD,OAAQA,EACR1I,MAAOA,+BAtWd+M,EAAAA,sDAxC2B+K,SACnBvL,SAFAS,SAGA4G,sBC6FL,SAAAmE,EACcC,EACFnS,EACAvF,EACA2X,GAHEtZ,KAAAqZ,UAAAA,EACFrZ,KAAAkH,cAAAA,EACAlH,KAAA2B,OAAAA,EACA3B,KAAAsZ,cAAAA,EARJtZ,KAAAmW,WAAqB,EACrBnW,KAAAiI,IAAc,KAUlBjI,KAAKqZ,UAAU/T,cAAcsC,UAAUC,IAAI9D,GAC3C/D,KAAK8T,cAAgB9T,KAAKuZ,oBAAoBvZ,KAAKkH,eACnDlH,KAAKiI,IAAMjI,KAAK8T,cAAchR,UAtFxBsW,EAAAxX,UAAAqV,OAAA,SAAO5Q,SACb,IAAIrG,KAAKmW,UAAT,CAGA,IAAMqD,EAAsF,QAAvErX,EAAIkE,EAAMoT,OAAuBC,QAAQ,sCAA8B,IAAAvX,OAAA,EAAAA,EAAEW,GAC9F,GAAI9C,KAAKiI,MAAQuR,EAKb,eADSnT,EAAMG,aAAamT,QAAQ,QAEpC3Z,KAAK2B,OAAO8U,SAASpQ,EAAOA,EAAMG,aAAamT,QAAQ,OAGvD3Z,KAAK2B,OAAOsV,OAAO5Q,KAMjB+S,EAAAxX,UAAAgY,WAAA,SAAWvT,GACjBA,EAAMwT,iBACF7Z,KAAKmW,WACTnW,KAAK2B,OAAO4V,YAAYlR,IAOlB+S,EAAAxX,UAAAkY,SAAA,SAASzT,GACXrG,KAAK8N,SAASnK,gBACd3D,KAAK2B,OAAOyB,UAAS,IAKnBgW,EAAAxX,UAAAmY,OAAA,SAAO1T,GACmB,UAA5BrG,KAAK8N,SAASlK,KAAKC,MACnB7D,KAAKga,iBAAiB3T,IAI9BxF,OAAA2D,eACI4U,EAAAxX,UAAA,YAAS,KADb,SACcqH,GACVjJ,KAAKsZ,cAAcrL,aAAahF,oCAGpCpI,OAAA2D,eACI4U,EAAAxX,UAAA,UAAO,KAOX,WACI,OAAO5B,KAAK8N,cAThB,SACYxF,GACRtI,KAAKsZ,cAAcvL,WAAWzF,GAC9BtI,KAAK8N,SAAW9N,KAAKsZ,cAAchR,QACnCtI,KAAK2B,OAAOyB,4CAQhBvC,OAAA2D,eAEI4U,EAAAxX,UAAA,WAAQ,KAOZ,WACI,OAAO5B,KAAKmW,eAVhB,SAEa8D,GACTja,KAAKmW,WAAoB,IAAR8D,EACbja,KAAK2B,SACL3B,KAAK2B,OAAOwU,UAAYnW,KAAKmW,4CAyBrCiD,EAAAxX,UAAAqD,SAAA,WACIjF,KAAK2B,OAAOsF,KAAKjH,KAAKkH,eACjBlH,KAAK8N,WACN9N,KAAKsI,QAAU,IAAI7G,EAAAA,YAAY6B,SAGnCtD,KAAK2B,OAAOwU,UAAYnW,KAAKmW,WAGjCiD,EAAAxX,UAAAsD,gBAAA,aAIAkU,EAAAxX,UAAAsY,YAAA,WAEI,IAAK,IAAI/Y,EAAI,EAAGA,EAAInB,KAAKkH,cAAczG,OAAQU,IAC3CnB,KAAKkH,cAAckN,OAAOjT,GAE9BnB,KAAKqZ,UAAU/T,cAAc8O,SAC7BpU,KAAKkH,cAAciM,QAAQ7N,cAAc8O,SACzCpU,KAAKkH,mBAAgBiT,GAGjBf,EAAAxX,UAAA2X,oBAAA,SAAoBrS,GACxB,IAAMkT,EAAW,IAAMlS,KAAKC,MAExBkR,EAAYnS,EAAciM,QAAQ7N,cAClCwO,EAAgBuG,SAASC,cAAc,OAI3C,OAHAxG,EAAchR,GAAKsX,EACnBtG,EAAclM,UAAUC,IAAI9D,GAC5BsV,EAAUlM,YAAY2G,GACfA,GAMJsF,EAAAxX,UAAA2Y,QAAA,WACH,OAAO,IAAI9Y,EAAAA,YAAYC,KAAK1B,KAAK2B,SAG9ByX,EAAAxX,UAAA+R,UAAA,WACH3T,KAAK2B,OAAOgS,aAGTyF,EAAAxX,UAAA6R,QAAA,WACHzT,KAAK2B,OAAO8R,WAGT2F,EAAAxX,UAAA4R,SAAA,SAASI,GAEZ,IAAM4G,EAAW3V,KAAKoG,IAAI,EAAG2I,GAC7B5T,KAAK2B,OAAO6R,SAASgH,IAGjBpB,EAAAxX,UAAAoY,iBAAA,SAAiB3T,GAEjBrG,KAAK2B,OAAOS,KAAK4N,YACjB3J,EAAMwT,iBAEFxT,EAAMoU,OAAS,EACfza,KAAK2T,YAGAtN,EAAMoU,OAAS,GACpBza,KAAKyT,qCAvKpBiH,EAAAA,UAASjV,KAAA,CAAC,CACPC,SAAU,sBACViV,UAAW,CACP7E,EACAb,EACArH,EACAS,gDAhB2BuM,EAAAA,kBAAiElF,EAAAA,wBAG3FI,SAEAlI,qCAgBJF,EAAAA,aAAYjI,KAAA,CAAC,OAAQ,CAAC,+BAoBtBiI,EAAAA,aAAYjI,KAAA,CAAC,WAAY,CAAC,6BAU1BiI,EAAAA,aAAYjI,KAAA,CAAC,gBAAiB,CAAC,2BAO/BiI,EAAAA,aAAYjI,KAAA,CAAC,QAAS,CAAC,8BAOvBI,EAAAA,MAAKJ,KAAA,CAAC,yCAKNI,EAAAA,MAAKJ,KAAA,CAAC,wCAYNI,EAAAA,MAAKJ,KAAA,CAAC,aAAU,CAAAmB,KAChBiU,EAAAA,YAAWpV,KAAA,CAAC,qCC1Db,SAAAqV,EACc3H,EACFtM,GADE7G,KAAAmT,QAAAA,EACFnT,KAAA6G,KAAAA,EAER7G,KAAKmT,QAAQ7N,cAAcC,aAAa,YAAa,eAnBzDuV,EAAAlZ,UAAA2V,YAAA,SAAYlR,GACRrG,KAAK6G,KAAKyN,YAAYtU,KAAK+a,UAC3B1U,EAAMG,aAAaC,QAAQ,OAAQ,iBAIvCqU,EAAAlZ,UAAAoZ,UAAA,SAAU3U,GAENrG,KAAK6G,KAAKyN,YAAY,OAc1BwG,EAAAlZ,UAAAsD,gBAAA,sCA5BHwV,EAAAA,UAASjV,KAAA,CAAC,CACPC,SAAU,iEALqBkV,EAAAA,kBAE1BvG,0CAOJ3G,EAAAA,aAAYjI,KAAA,CAAC,YAAa,CAAC,8BAM3BiI,EAAAA,aAAYjI,KAAA,CAAC,UAAW,CAAC,6BAOzBI,EAAAA,MAAKJ,KAAA,CAAC,4BCJX,iCAXCwV,EAAAA,SAAQxV,KAAA,CAAC,CACRyV,aAAc,CAAC9B,EAA4B0B,EAA0BhV,EAA0B9B,GAC/FmX,QAAS,CACPC,EAAAA,cAEFC,QAAS,CAACjC,EAA4B0B,EAA0BhV,EAA0B9B,GAC1FsX,gBAAiB,CACfxV,EACA9B","sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","import { TemplateRef, Type } from '@angular/core';\r\nimport { NgFlowchartCanvasService } from '../ng-flowchart-canvas.service';\r\nimport { NgFlowchartStepComponent } from '../ng-flowchart-step/ng-flowchart-step.component';\r\n\r\nexport namespace NgFlowchart {\r\n    export class Flow {\r\n        constructor(private canvas: NgFlowchartCanvasService) {\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns the json representation of this flow\r\n         * @param indent Optional indent to specify for formatting\r\n         */\r\n        toJSON(indent?: number) {\r\n            return JSON.stringify(this.toObject(), null, indent);\r\n        }\r\n\r\n        toObject() {\r\n            return {\r\n                root: this.canvas.flow.rootStep?.toJSON()\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Create a flow and render it on the canvas from a json string\r\n         * @param json The json string of the flow to render\r\n         */\r\n        async upload(json: string | object): Promise<void> {\r\n            let jsonObj = typeof json === 'string' ? JSON.parse(json) : json\r\n            let root: any = jsonObj.root;\r\n            this.clear();\r\n\r\n            await this.canvas.upload(root);\r\n        }\r\n\r\n        /**\r\n         * Returns the root step of the flow chart\r\n         */\r\n        getRoot(): NgFlowchartStepComponent {\r\n            return this.canvas.flow.rootStep;\r\n        }\r\n\r\n        /**\r\n         * Finds a step in the flow chart by a given id\r\n         * @param id Id of the step to find. By default, the html id of the step\r\n         */\r\n        getStep(id): NgFlowchartStepComponent {\r\n            return this.canvas.flow.steps.find(child => child.id == id);\r\n        }\r\n\r\n        /**\r\n         * Re-renders the canvas. Generally this should only be used in rare circumstances\r\n         * @param pretty Attempt to recenter the flow in the canvas\r\n         */\r\n        render(pretty?: boolean) {\r\n            this.canvas.reRender(pretty);\r\n        }\r\n\r\n        /**\r\n         * Clears all flow chart, reseting the current canvas\r\n         */\r\n        clear() {\r\n            if (this.canvas.flow?.rootStep) {\r\n                this.canvas.flow.rootStep.destroy(true, false);\r\n                this.canvas.reRender();\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    export class Options {\r\n        /** The gap (in pixels) between flow steps*/\r\n        stepGap?: number = 40;\r\n\r\n        /** An inner deadzone radius (in pixels) that will not register the hover icon  */\r\n        hoverDeadzoneRadius?: number = 20;\r\n\r\n        /** Is the flow sequential? If true, then you will not be able to drag parallel steps */\r\n        isSequential?: boolean = false;\r\n\r\n        /** The default root position when dropped. Default is TOP_CENTER */\r\n        rootPosition?: 'TOP_CENTER' | 'CENTER' | 'FREE' = 'TOP_CENTER';\r\n\r\n        /** Should the canvas be centered when a resize is detected? */\r\n        centerOnResize?: boolean = true;\r\n\r\n        /** Canvas zoom options. Defaults to mouse wheel zoom */\r\n        zoom?: {\r\n            mode: 'WHEEL' | 'MANUAL' | 'DISABLED'\r\n            defaultStep?: number\r\n        } = {\r\n            mode: 'WHEEL',\r\n            defaultStep: .1\r\n        }\r\n    }\r\n\r\n    export type DropEvent = {\r\n        step: NgFlowchartStepComponent,\r\n        parent?: NgFlowchartStepComponent,\r\n        isMove: boolean\r\n    }\r\n\r\n    export type DropError = {\r\n        step: PendingStep,\r\n        parent?: NgFlowchartStepComponent,\r\n        error: ErrorMessage\r\n    }\r\n\r\n    export type MoveError = {\r\n        step: MoveStep,\r\n        parent?: NgFlowchartStepComponent,\r\n        error: ErrorMessage\r\n    }\r\n\r\n    export type ErrorMessage = {\r\n        code?: string,\r\n        message?: string\r\n    }\r\n\r\n    export interface MoveStep extends Step {\r\n        instance: NgFlowchartStepComponent\r\n    }\r\n\r\n    export interface PendingStep extends Step {\r\n        /**\r\n         * An Ng-template containing the canvas content to be displayed. \r\n         * Or a component type that extends NgFlowchartStepComponent\r\n         */\r\n        template: TemplateRef<any> | Type<NgFlowchartStepComponent>\r\n    }\r\n\r\n    export interface Step {\r\n        /**\r\n         * A unique string indicating the type of step this is.\r\n         * This type will be used to register steps if you are uploading from json.\r\n         */\r\n        type: string,\r\n        /**\r\n         * Optional data to give the step. Typically configuration data that users can edit on the step.\r\n         */\r\n        data?: any\r\n    }\r\n\r\n\r\n\r\n    export type DropTarget = {\r\n        step: NgFlowchartStepComponent,\r\n        position: DropPosition\r\n    }\r\n\r\n    export type DropStatus = 'SUCCESS' | 'PENDING' | 'FAILED';\r\n    export type DropPosition = 'RIGHT' | 'LEFT' | 'BELOW' | 'ABOVE';\r\n\r\n    export type Callbacks = {\r\n\r\n        /**\r\n         * Called when user drops a new step from the palette or moves an existing step\r\n         */\r\n        onDropStep?: (drop: DropEvent) => void;\r\n\r\n        /**\r\n         * Called when the delete method has been called on the step\r\n         */\r\n        beforeDeleteStep?: (step: NgFlowchartStepComponent) => void;\r\n\r\n        /**\r\n         * Called after the delete method has run on the step. If you need to access\r\n         * step children or parents, use beforeDeleteStep\r\n         */\r\n        afterDeleteStep?: (step: NgFlowchartStepComponent) => void;\r\n\r\n        /**\r\n         * Called when a new step fails to drop on the canvas\r\n         */\r\n        onDropError?: (drop: DropError) => void;\r\n\r\n        /**\r\n         * Called when an existing step fails to move\r\n         */\r\n        onMoveError?: (drop: MoveError) => void;\r\n\r\n        /**\r\n         * Called before the canvas is about to re-render\r\n         */\r\n        beforeRender?: () => void\r\n\r\n        /**\r\n         * Called after the canvas completes a re-render\r\n         */\r\n        afterRender?: () => void        \r\n\r\n        /**\r\n         * Called after the canvas has been scaled\r\n         */\r\n        afterScale?: (newScale: number) => void\r\n    };\r\n}\r\n\r\n\r\n\r\n\r\n","export const CONSTANTS = {\r\n    DROP_HOVER_ATTR: 'ngflowchart-drop-hover',\r\n    CANVAS_CONTENT_CLASS: 'ngflowchart-canvas-content',\r\n    CANVAS_CONTENT_ID: 'ngflowchart-canvas-content',\r\n    CANVAS_CLASS: 'ngflowchart-canvas',\r\n    CANVAS_STEP_CLASS: 'ngflowchart-canvas-step',\r\n}","import { AfterViewInit, Component, ElementRef, Input, OnInit, ViewChild } from '@angular/core';\r\n\r\n@Component({\r\n  selector: 'lib-ng-flowchart-arrow',\r\n  templateUrl: './ng-flowchart-arrow.component.html',\r\n  styleUrls: ['./ng-flowchart-arrow.component.scss']\r\n})\r\nexport class NgFlowchartArrowComponent implements OnInit, AfterViewInit {\r\n\r\n  @ViewChild('arrow')\r\n  arrow: ElementRef;\r\n\r\n  @Input()\r\n  set position(pos: { start: number[], end: number[] }) {\r\n    this._position = pos;\r\n\r\n    this.isLeftFlowing = pos.start[0] > pos.end[0];\r\n\r\n    //in the case where steps are directly underneath we need some minimum width\r\n    this.containerWidth = Math.abs(pos.start[0] - pos.end[0]) + (this.padding * 2);\r\n\r\n    this.containerLeft = Math.min(pos.start[0], pos.end[0]) - this.padding;\r\n\r\n    this.containerHeight = Math.abs(pos.start[1] - pos.end[1]);\r\n    this.containerTop = pos.start[1];\r\n\r\n    this.updatePath();\r\n  }\r\n\r\n  opacity = 1;\r\n  containerWidth: number = 0;\r\n  containerHeight: number = 0;\r\n  containerLeft: number = 0;\r\n  containerTop: number = 0;\r\n  _position: { start: number[], end: number[] }\r\n\r\n\r\n  //to be applied on left and right edges\r\n  private padding = 10;\r\n  private isLeftFlowing = false;\r\n\r\n  constructor() { }\r\n\r\n  ngOnInit(): void {\r\n  }\r\n\r\n  ngAfterViewInit() {\r\n    this.updatePath();\r\n  }\r\n\r\n  hideArrow() {\r\n    this.opacity = .2;\r\n  }\r\n\r\n  showArrow() {\r\n    this.opacity = 1;\r\n  }\r\n\r\n  private updatePath() {\r\n    if (!this.arrow?.nativeElement) {\r\n      return;\r\n    }\r\n\r\n    if (this.isLeftFlowing) {\r\n      this.arrow.nativeElement.setAttribute(\"d\", `\r\n        M${this.containerWidth - this.padding},0 \r\n        L${this.containerWidth - this.padding},${this.containerHeight / 2}\r\n        L${this.padding},${this.containerHeight / 2}\r\n        L${this.padding},${this.containerHeight - 4}\r\n      `);\r\n    }\r\n    else {\r\n      this.arrow.nativeElement.setAttribute(\"d\", `\r\n        M${this.padding},0 \r\n        L${this.padding},${this.containerHeight / 2}\r\n        L${this.containerWidth - this.padding},${this.containerHeight / 2}\r\n        L${this.containerWidth - this.padding},${this.containerHeight - 4}\r\n      `);\r\n    }\r\n\r\n\r\n  }\r\n\r\n}\r\n","import { Component, ComponentFactoryResolver, ComponentRef, ElementRef, EventEmitter, HostListener, Input, Output, TemplateRef, ViewChild, ViewContainerRef, ViewEncapsulation } from '@angular/core';\r\nimport { NgFlowchart } from '../model/flow.model';\r\nimport { CONSTANTS } from '../model/flowchart.constants';\r\nimport { NgFlowchartArrowComponent } from '../ng-flowchart-arrow/ng-flowchart-arrow.component';\r\nimport { NgFlowchartCanvasService } from '../ng-flowchart-canvas.service';\r\nimport { DropDataService } from '../services/dropdata.service';\r\n\r\nexport type AddChildOptions = {\r\n  /** Should the child be added as a sibling to existing children, if false the existing children will be reparented to this new child.\r\n   * Default is true.\r\n   * */\r\n  sibling?: boolean,\r\n  /** The index of the child. Only used when sibling is true.\r\n   * Defaults to the end of the child array. \r\n   */\r\n  index?: number\r\n}\r\n\r\n@Component({\r\n  selector: 'ng-flowchart-step',\r\n  templateUrl: './ng-flowchart-step.component.html',\r\n  styleUrls: ['./ng-flowchart-step.component.scss'],\r\n  encapsulation: ViewEncapsulation.None\r\n})\r\nexport class NgFlowchartStepComponent<T = any> {\r\n\r\n  @HostListener('dragstart', ['$event'])\r\n  onMoveStart(event: DragEvent) {\r\n    if (this.canvas.disabled) { return; }\r\n    this.hideTree();\r\n    event.dataTransfer.setData('type', 'FROM_CANVAS');\r\n    event.dataTransfer.setData('id', this.nativeElement.id);\r\n\r\n\r\n    this.drop.dragStep = {\r\n      type: this.type,\r\n      data: this.data,\r\n      instance: this\r\n    }\r\n  }\r\n\r\n  @HostListener('dragend', ['$event'])\r\n  onMoveEnd(event: DragEvent) {\r\n    this.showTree();\r\n  }\r\n\r\n  //could potentially try to make this abstract\r\n  @ViewChild('canvasContent')\r\n  protected view: ElementRef;\r\n\r\n  @Input()\r\n  data: T;\r\n\r\n  @Input()\r\n  type: string;\r\n\r\n  @Input()\r\n  canvas: NgFlowchartCanvasService;\r\n\r\n  @Input()\r\n  compRef: ComponentRef<NgFlowchartStepComponent>;\r\n\r\n  @Output()\r\n  viewInit = new EventEmitter();\r\n\r\n  @Input()\r\n  contentTemplate: TemplateRef<any>;\r\n\r\n\r\n  private _id: any;\r\n  private _currentPosition = [0, 0];\r\n\r\n  //only used if something tries to set the position before view has been initialized\r\n  private _initPosition;\r\n  private _isHidden = false;\r\n  private _parent: NgFlowchartStepComponent;\r\n  private _children: Array<NgFlowchartStepComponent>;\r\n  private arrow: ComponentRef<NgFlowchartArrowComponent>;\r\n\r\n  private drop: DropDataService;\r\n  private viewContainer: ViewContainerRef;\r\n  private compFactory: ComponentFactoryResolver;\r\n\r\n  constructor() {\r\n    this._children = [];\r\n  }\r\n\r\n  init(drop, viewContainer, compFactory) {\r\n    this.drop = drop;\r\n    this.viewContainer = viewContainer;\r\n    this.compFactory = compFactory;\r\n  }\r\n\r\n  canDeleteStep(): boolean {\r\n    return true;\r\n  }\r\n\r\n  canDrop(dropEvent: NgFlowchart.DropTarget, error: NgFlowchart.ErrorMessage): boolean {\r\n    return true;\r\n  }\r\n\r\n  shouldEvalDropHover(coords: number[], stepToDrop: NgFlowchart.Step): boolean {\r\n    return true\r\n  }\r\n\r\n  async onUpload(data: T) { }\r\n\r\n  getDropPositionsForStep(step: NgFlowchart.Step): NgFlowchart.DropPosition[] {\r\n    return ['BELOW', 'LEFT', 'RIGHT', 'ABOVE'];\r\n  }\r\n\r\n  ngOnInit(): void {\r\n\r\n  }\r\n\r\n  ngAfterViewInit() {\r\n    if (!this.nativeElement) {\r\n      throw 'Missing canvasContent ViewChild. Be sure to add #canvasContent to your root html element.'\r\n    }\r\n\r\n\r\n    this.nativeElement.classList.add('ngflowchart-step-wrapper');\r\n    this.nativeElement.setAttribute('draggable', 'true');\r\n\r\n    if (this._initPosition) {\r\n      this.zsetPosition(this._initPosition);\r\n    }\r\n\r\n    //force id creation if not already there\r\n    this.nativeElement.id = this.id;\r\n\r\n    this.viewInit.emit();\r\n  }\r\n\r\n  get id() {\r\n    if (this._id == null) {\r\n      this._id = 's' + Date.now();\r\n    }\r\n    return this._id;\r\n  }\r\n\r\n  get currentPosition() {\r\n    return this._currentPosition;\r\n  }\r\n\r\n  /**\r\n   * Creates and adds a child to this step\r\n   * @param template The template or component type to create\r\n   * @param options Add options \r\n   */\r\n  async addChild(pending: NgFlowchart.PendingStep, options: AddChildOptions): Promise<NgFlowchartStepComponent | null> {\r\n\r\n    let componentRef = await this.canvas.createStep(pending);\r\n    this.canvas.addToCanvas(componentRef);\r\n    if (options?.sibling) {\r\n      this.zaddChildSibling0(componentRef.instance, options?.index);\r\n    }\r\n    else {\r\n      this.zaddChild0(componentRef.instance);\r\n    }\r\n\r\n    this.canvas.flow.addStep(componentRef.instance);\r\n\r\n    this.canvas.reRender();\r\n\r\n    return componentRef.instance;\r\n  }\r\n\r\n  /**\r\n   * Destroys this step component and updates all necessary child and parent relationships\r\n   * @param recursive \r\n   * @param checkCallbacks \r\n   */\r\n  destroy(recursive: boolean = true, checkCallbacks: boolean = true): boolean {\r\n\r\n    if (!checkCallbacks || this.canDeleteStep()) {\r\n      this.canvas.options.callbacks.beforeDeleteStep && \r\n      this.canvas.options.callbacks.beforeDeleteStep(this)\r\n      \r\n      let parentIndex;\r\n      if (this._parent) {\r\n        parentIndex = this._parent.removeChild(this);\r\n      }\r\n\r\n      this.destroy0(parentIndex, recursive);\r\n\r\n      this.canvas.reRender();\r\n\r\n      this.canvas.options.callbacks.afterDeleteStep && \r\n      this.canvas.options.callbacks.afterDeleteStep(this)\r\n\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * Remove a child from this step. Returns the index at which the child was found or -1 if not found.\r\n   * @param childToRemove Step component to remove\r\n   */\r\n  removeChild(childToRemove: NgFlowchartStepComponent): number {\r\n    if (!this.children) {\r\n      return -1;\r\n    }\r\n    const i = this.children.findIndex(child => child.id == childToRemove.id);\r\n    if (i > -1) {\r\n      this.children.splice(i, 1);\r\n    }\r\n\r\n    return i;\r\n  }\r\n\r\n  /**\r\n   * Re-parent this step\r\n   * @param newParent The new parent for this step\r\n   * @param force Force the re-parent if a parent already exists\r\n   */\r\n  setParent(newParent: NgFlowchartStepComponent, force: boolean = false): void {\r\n    if (this.parent && !force) {\r\n      console.warn('This child already has a parent, use force if you know what you are doing');\r\n      return;\r\n    }\r\n    this._parent = newParent;\r\n    if (!this._parent && this.arrow) {\r\n      this.arrow.destroy();\r\n      this.arrow = null;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Called when no longer trying to drop or move a step adjacent to this one\r\n   * @param position Position to render the icon\r\n   */\r\n  clearHoverIcons() {\r\n    this.nativeElement.removeAttribute(CONSTANTS.DROP_HOVER_ATTR);\r\n  }\r\n\r\n  /**\r\n   * Called when a step is trying to be dropped or moved adjacent to this step.\r\n   * @param position Position to render the icon\r\n   */\r\n  showHoverIcon(position: NgFlowchart.DropPosition) {\r\n    this.nativeElement.setAttribute(CONSTANTS.DROP_HOVER_ATTR, position.toLowerCase());\r\n  }\r\n\r\n  /**\r\n   * Is this the root element of the tree\r\n   */\r\n  isRootElement() {\r\n    return !this.parent;\r\n  }\r\n\r\n  /**\r\n   * Does this step have any children?\r\n   * @param count Optional count of children to check. Defaults to 1. I.E has at least 1 child.\r\n   */\r\n  hasChildren(count: number = 1) {\r\n    return this.children && this.children.length >= count;\r\n  }\r\n\r\n  /** Array of children steps for this step */\r\n  get children() {\r\n    return this._children;\r\n  }\r\n\r\n  /** The parent step of this step */\r\n  get parent() {\r\n    return this._parent;\r\n  }\r\n\r\n  /**\r\n   * Returns the total width extent (in pixels) of this node tree\r\n   * @param stepGap The current step gap for the flow canvas\r\n   */\r\n  getNodeTreeWidth(stepGap: number) {\r\n    const currentNodeWidth = this.nativeElement.getBoundingClientRect().width;\r\n\r\n    if (!this.hasChildren()) {\r\n      return this.nativeElement.getBoundingClientRect().width;\r\n    }\r\n\r\n    let childWidth = this._children.reduce((childTreeWidth, child) => {\r\n      return childTreeWidth += child.getNodeTreeWidth(stepGap);\r\n    }, 0)\r\n\r\n    childWidth += stepGap * (this._children.length - 1);\r\n\r\n    return Math.max(currentNodeWidth, childWidth);\r\n  }\r\n\r\n  /**\r\n   * Is this step currently hidden and unavailable as a drop location\r\n   */\r\n  isHidden() {\r\n    return this._isHidden;\r\n  }\r\n\r\n  /**\r\n   * Return current rect of this step. The position can be animated so getBoundingClientRect cannot \r\n   * be reliable for positions\r\n   * @param canvasRect Optional canvasRect to provide to offset the values\r\n   */\r\n  getCurrentRect(canvasRect?: DOMRect): Partial<DOMRect> {\r\n    let clientRect = this.nativeElement.getBoundingClientRect();\r\n\r\n    return {\r\n      bottom: this._currentPosition[1] + clientRect.height + (canvasRect?.top || 0),\r\n      left: this._currentPosition[0] + (canvasRect?.left || 0),\r\n      height: clientRect.height,\r\n      width: clientRect.width,\r\n      right: this._currentPosition[0] + clientRect.width + (canvasRect?.left || 0),\r\n      top: this._currentPosition[1] + (canvasRect?.top || 0)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the JSON representation of this flow step\r\n   */\r\n  toJSON() {\r\n    return {\r\n      id: this.id,\r\n      type: this.type,\r\n      data: this.data,\r\n      children: this.hasChildren() ? this._children.map(child => {\r\n        return child.toJSON()\r\n      }) : []\r\n    }\r\n  }\r\n\r\n  /** The native HTMLElement of this step */\r\n  get nativeElement(): HTMLElement {\r\n    return this.view?.nativeElement;\r\n  }\r\n\r\n  setId(id) {\r\n    this._id = id;\r\n  }\r\n\r\n  zsetPosition(pos: number[], offsetCenter: boolean = false) {\r\n\r\n    if (!this.view) {\r\n      console.warn('Trying to set position before view init');\r\n      //save pos and set in after view init\r\n      this._initPosition = [...pos];\r\n      return;\r\n    }\r\n\r\n    let adjustedX = Math.max(pos[0] - (offsetCenter ? this.nativeElement.offsetWidth / 2 : 0), 0);\r\n    let adjustedY = Math.max(pos[1] - (offsetCenter ? this.nativeElement.offsetHeight / 2 : 0), 0);\r\n\r\n    this.nativeElement.style.left = `${adjustedX}px`;\r\n    this.nativeElement.style.top = `${adjustedY}px`;\r\n\r\n    this._currentPosition = [adjustedX, adjustedY];\r\n  }\r\n\r\n  zaddChild0(newChild: NgFlowchartStepComponent): boolean {\r\n    let oldChildIndex = null\r\n    if (newChild._parent) {\r\n      oldChildIndex = newChild._parent.removeChild(newChild);\r\n    }\r\n\r\n    if (this.hasChildren()) {\r\n      if (newChild.hasChildren()) {\r\n        //if we have children and the child has children we need to confirm the child doesnt have multiple children at any point\r\n        let newChildLastChild = newChild.findLastSingleChild();\r\n        if (!newChildLastChild) {\r\n          newChild._parent.zaddChildSibling0(newChild, oldChildIndex)\r\n          console.error('Invalid move. A node cannot have multiple parents');\r\n          return false;\r\n        }\r\n        //move the this nodes children to last child of the step arg\r\n        newChildLastChild.setChildren(this._children.slice());\r\n      }\r\n      else {\r\n        //move adjacent's children to newStep\r\n        newChild.setChildren(this._children.slice());\r\n      }\r\n\r\n    }\r\n    //finally reset this nodes to children to the single new child\r\n    this.setChildren([newChild]);\r\n    return true;\r\n  }\r\n\r\n  zaddChildSibling0(child: NgFlowchartStepComponent, index?: number): void {\r\n    if (child._parent) {\r\n      child._parent.removeChild(child);\r\n    }\r\n\r\n    if (!this.children) {\r\n      this._children = [];\r\n    }\r\n    if (index == null) {\r\n      this.children.push(child);\r\n    }\r\n    else {\r\n      this.children.splice(index, 0, child);\r\n    }\r\n\r\n    //since we are adding a new child here, it is safe to force set the parent\r\n    child.setParent(this, true);\r\n  }\r\n\r\n  zdrawArrow(start: number[], end: number[]) {\r\n    if (!this.arrow) {\r\n      this.createArrow();\r\n    }\r\n    this.arrow.instance.position = {\r\n      start: start,\r\n      end: end\r\n    };\r\n  }\r\n\r\n  ////////////////////////\r\n  // PRIVATE IMPL\r\n\r\n  private destroy0(parentIndex, recursive: boolean = true) {\r\n\r\n    this.compRef.destroy();\r\n    \r\n    // remove from master array\r\n    this.canvas.flow.removeStep(this)\r\n\r\n    if (this.isRootElement()) {\r\n      this.canvas.flow.rootStep = null;\r\n    }\r\n\r\n    if (this.hasChildren()) {\r\n\r\n      //this was the root node\r\n      if (this.isRootElement()) {\r\n\r\n        if (!recursive) {\r\n\r\n          let newRoot = this._children[0];\r\n          //set first child as new root\r\n          this.canvas.flow.rootStep = newRoot;\r\n          newRoot.setParent(null, true);\r\n\r\n          //make previous siblings children of the new root\r\n          if (this.hasChildren(2)) {\r\n            for (let i = 1; i < this._children.length; i++) {\r\n              let child = this._children[i];\r\n              child.setParent(newRoot, true);\r\n              newRoot._children.push(child);\r\n            }\r\n          }\r\n        }\r\n\r\n      }\r\n\r\n      //update children\r\n      let length = this._children.length;\r\n      for (let i = 0; i < length; i++) {\r\n        let child = this._children[i];\r\n        if (recursive) {\r\n          (child as NgFlowchartStepComponent).destroy0(null, true);\r\n        }\r\n\r\n        //not the original root node\r\n        else if (!!this._parent) {\r\n          this._parent._children.splice(i + parentIndex, 0, child);\r\n          child.setParent(this._parent, true);\r\n        }\r\n      }\r\n      this.setChildren([]);\r\n    }\r\n    this._parent = null;\r\n  }\r\n\r\n  private createArrow() {\r\n    const factory = this.compFactory.resolveComponentFactory(NgFlowchartArrowComponent)\r\n    this.arrow = this.viewContainer.createComponent(factory);\r\n    this.nativeElement.parentElement.appendChild(this.arrow.location.nativeElement);\r\n  }\r\n\r\n  private hideTree() {\r\n    this._isHidden = true;\r\n    this.nativeElement.style.opacity = '.4';\r\n\r\n    if (this.arrow) {\r\n      this.arrow.instance.hideArrow();\r\n    }\r\n\r\n    if (this.hasChildren()) {\r\n      this._children.forEach(child => {\r\n        child.hideTree();\r\n      })\r\n    }\r\n  }\r\n\r\n  private showTree() {\r\n    this._isHidden = false;\r\n\r\n    if (this.arrow) {\r\n      this.arrow.instance.showArrow();\r\n    }\r\n\r\n    this.nativeElement.style.opacity = '1';\r\n    if (this.hasChildren()) {\r\n      this._children.forEach(child => {\r\n        child.showTree();\r\n      })\r\n    }\r\n  }\r\n\r\n  private findLastSingleChild() {\r\n    //two or more children means we have no single child\r\n    if (this.hasChildren(2)) {\r\n      return null;\r\n    }\r\n    //if one child.. keep going down the tree until we find no children or 2 or more\r\n    else if (this.hasChildren()) {\r\n      return this._children[0].findLastSingleChild();\r\n    }\r\n    //if no children then this is the last single child\r\n    else return this;\r\n  }\r\n\r\n  private setChildren(children: Array<NgFlowchartStepComponent>): void {\r\n    this._children = children;\r\n    this.children.forEach(child => {\r\n      child.setParent(this, true);\r\n    })\r\n  }\r\n\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { NgFlowchart } from '../model/flow.model';\r\n\r\n@Injectable()\r\nexport class OptionsService {\r\n\r\n    private _options: NgFlowchart.Options;\r\n    private _callbacks: NgFlowchart.Callbacks = {};\r\n\r\n    constructor() {\r\n        this._options = new NgFlowchart.Options();\r\n    }\r\n\r\n    setOptions(options) {\r\n        this._options = this.sanitizeOptions(options);        \r\n    }\r\n\r\n    setCallbacks(callbacks) {\r\n        this._callbacks = callbacks;\r\n    }\r\n\r\n    get options() {\r\n        return this._options;\r\n    }\r\n\r\n    get callbacks() {\r\n        return this._callbacks;\r\n    }\r\n\r\n    private sanitizeOptions(options: NgFlowchart.Options): NgFlowchart.Options {\r\n        const defaultOpts = new NgFlowchart.Options();\r\n\r\n        options = {\r\n          ...defaultOpts,\r\n          ...options\r\n        };\r\n    \r\n        options.stepGap = Math.max(options.stepGap, 20) || 40;\r\n        options.hoverDeadzoneRadius = Math.max(options.hoverDeadzoneRadius, 0) || 20;\r\n    \r\n        return options;\r\n    }\r\n}","import { ComponentRef, Injectable, ViewContainerRef } from '@angular/core';\r\nimport { NgFlowchart } from '../model/flow.model';\r\nimport { CONSTANTS } from '../model/flowchart.constants';\r\nimport { CanvasFlow } from '../ng-flowchart-canvas.service';\r\nimport { NgFlowchartStepComponent } from '../ng-flowchart-step/ng-flowchart-step.component';\r\nimport { OptionsService } from './options.service';\r\n\r\nexport type DropProximity = {\r\n    step: NgFlowchartStepComponent,\r\n    position: NgFlowchart.DropPosition,\r\n    proximity: number\r\n};\r\n\r\n@Injectable()\r\nexport class CanvasRendererService {\r\n    private viewContainer: ViewContainerRef;\r\n\r\n    private scale: number = 1;\r\n    private scaleDebounceTimer = null\r\n\r\n    constructor(\r\n        private options: OptionsService\r\n    ) {\r\n\r\n    }\r\n\r\n    public init(viewContainer: ViewContainerRef) {\r\n        this.viewContainer = viewContainer;\r\n    }\r\n\r\n    public renderRoot(step: ComponentRef<NgFlowchartStepComponent>, dragEvent?: DragEvent) {\r\n        this.getCanvasContentElement().appendChild((step.location.nativeElement));\r\n        this.setRootPosition(step.instance, dragEvent);\r\n    }\r\n\r\n    public renderNonRoot(step: ComponentRef<NgFlowchartStepComponent>, dragEvent?: DragEvent) {\r\n        this.getCanvasContentElement().appendChild((step.location.nativeElement));\r\n    }\r\n\r\n    public updatePosition(step: NgFlowchartStepComponent, dragEvent: DragEvent) {\r\n        let relativeXY = this.getRelativeXY(dragEvent);\r\n\r\n        relativeXY = relativeXY.map(coord => coord / this.scale)\r\n        step.zsetPosition(relativeXY, true);\r\n    }\r\n\r\n    private getStepGap() {\r\n        return this.options.options.stepGap;\r\n    }\r\n\r\n    private renderChildTree(rootNode: NgFlowchartStepComponent, rootRect: Partial<DOMRect>, canvasRect: DOMRect) {\r\n        //the rootNode passed in is already rendered. just need to render its children /subtree\r\n\r\n        if (!rootNode.hasChildren()) {\r\n            return;\r\n        }\r\n\r\n        //top of the child row is simply the relative bottom of the root + stepGap\r\n        const childYTop = (rootRect.bottom - canvasRect.top * this.scale) + this.getStepGap();\r\n  \r\n        const rootWidth = rootRect.width / this.scale\r\n\r\n        const rootXCenter = (rootRect.left - canvasRect.left) + (rootWidth / 2);\r\n\r\n\r\n        //get the width of the child trees\r\n        let childTreeWidths = {};\r\n        let totalTreeWidth = 0;\r\n\r\n        rootNode.children.forEach(child => {\r\n            let totalChildWidth = child.getNodeTreeWidth(this.getStepGap());\r\n            totalChildWidth = totalChildWidth / this.scale\r\n            childTreeWidths[child.nativeElement.id] = totalChildWidth;\r\n\r\n            totalTreeWidth += totalChildWidth;\r\n        });\r\n\r\n        //add length for stepGaps between child trees\r\n        totalTreeWidth += (rootNode.children.length - 1) * this.getStepGap();\r\n\r\n        //if we have more than 1 child, we want half the extent on the left and half on the right\r\n        let leftXTree = rootXCenter - (totalTreeWidth / 2);\r\n        \r\n        // dont allow it to go negative since you cant scroll that way\r\n        leftXTree = Math.max(0, leftXTree)\r\n\r\n        rootNode.children.forEach(child => {\r\n\r\n            let childExtent = childTreeWidths[child.nativeElement.id];\r\n\r\n            let childLeft = leftXTree + (childExtent / 2) - (child.nativeElement.offsetWidth / 2);\r\n\r\n\r\n            child.zsetPosition([childLeft, childYTop]);\r\n\r\n            const currentChildRect = child.getCurrentRect(canvasRect);\r\n\r\n            const childWidth = currentChildRect.width / this.scale\r\n           \r\n            child.zdrawArrow(\r\n                [rootXCenter, (rootRect.bottom - canvasRect.top * this.scale)],\r\n                [currentChildRect.left + childWidth / 2 - canvasRect.left, currentChildRect.top - canvasRect.top]\r\n            );\r\n\r\n            this.renderChildTree(child, currentChildRect, canvasRect);\r\n            leftXTree += childExtent + this.getStepGap();\r\n        })\r\n\r\n    }\r\n\r\n\r\n    public render(flow: CanvasFlow, pretty?: boolean, skipAdjustDimensions = false) {\r\n        if (!flow.hasRoot()) {\r\n            if (this.options.options.zoom.mode === 'DISABLED') {\r\n                this.resetAdjustDimensions();\r\n                // Trigger afterRender to allow nested canvas to redraw parent canvas.\r\n                // Not sure if this scenario should also trigger beforeRender.\r\n                if (this.options.callbacks?.afterRender) {\r\n                    this.options.callbacks.afterRender()\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        if (this.options.callbacks?.beforeRender) {\r\n            this.options.callbacks.beforeRender()\r\n        }\r\n\r\n        const canvasRect = this.getCanvasContentElement().getBoundingClientRect();\r\n        if (pretty) {\r\n            //this will place the root at the top center of the canvas and render from there\r\n            this.setRootPosition(flow.rootStep, null);\r\n        }\r\n        this.renderChildTree(flow.rootStep, flow.rootStep.getCurrentRect(canvasRect), canvasRect);\r\n        \r\n        if (!skipAdjustDimensions && this.options.options.zoom.mode === 'DISABLED') {\r\n            this.adjustDimensions(flow, canvasRect);\r\n        }\r\n\r\n        if (this.options.callbacks?.afterRender) {\r\n            this.options.callbacks.afterRender()\r\n        }\r\n    }\r\n\r\n    private resetAdjustDimensions(): void {\r\n        // reset canvas auto sizing to original size if empty\r\n        if (this.viewContainer) {\r\n            const canvasWrapper = this.getCanvasContentElement();\r\n            canvasWrapper.style.minWidth = null;\r\n            canvasWrapper.style.minHeight = null;\r\n        }\r\n    }\r\n           \r\n\r\n    private findDropLocationForHover(absMouseXY: number[], targetStep: NgFlowchartStepComponent, stepToDrop: NgFlowchart.Step): DropProximity | 'deadzone' | null {\r\n\r\n        if (!targetStep.shouldEvalDropHover(absMouseXY, stepToDrop)) {\r\n            return 'deadzone'\r\n        }\r\n\r\n        const stepRect = targetStep.nativeElement.getBoundingClientRect();\r\n\r\n        const yStepCenter = stepRect.bottom - stepRect.height / 2;\r\n        const xStepCenter = stepRect.left + stepRect.width / 2;\r\n\r\n        const yDiff = absMouseXY[1] - yStepCenter;\r\n        const xDiff = absMouseXY[0] - xStepCenter;\r\n\r\n        const absYDistance = Math.abs(yDiff);\r\n        const absXDistance = Math.abs(xDiff);\r\n\r\n        //#math class #Pythagoras\r\n        const distance = Math.sqrt(absYDistance * absYDistance + absXDistance * absXDistance);\r\n        const accuracyRadius = (stepRect.height + stepRect.width) / 2;\r\n\r\n        let result: DropProximity | 'deadzone' | null = null;\r\n\r\n        if (distance < accuracyRadius) {\r\n            if (distance < this.options.options.hoverDeadzoneRadius) {\r\n                //basically we are too close to the middle to accurately predict what position they want\r\n                result = 'deadzone';\r\n            }\r\n\r\n            if (absYDistance > absXDistance) {\r\n                result = {\r\n                    step: targetStep,\r\n                    position: yDiff > 0 ? 'BELOW' : 'ABOVE',\r\n                    proximity: absYDistance\r\n                };\r\n            }\r\n            else if (!this.options.options.isSequential && !targetStep.isRootElement()) {\r\n                result = {\r\n                    step: targetStep,\r\n                    position: xDiff > 0 ? 'RIGHT' : 'LEFT',\r\n                    proximity: absXDistance\r\n                };\r\n            }\r\n        }\r\n\r\n        if (result && result !== 'deadzone') {\r\n            if (!targetStep.getDropPositionsForStep(stepToDrop).includes(result.position)) {\r\n                //we had a valid drop but the target step doesnt allow this location\r\n                result = null;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private adjustDimensions(flow: CanvasFlow, canvasRect: DOMRect): void {\r\n        let maxRight = 0;\r\n        let maxBottom = 0;\r\n\r\n        //TODO this can be better\r\n        flow.steps.forEach(\r\n            ele => {\r\n                let rect = ele.getCurrentRect(canvasRect);\r\n                maxRight = Math.max(rect.right, maxRight);\r\n                maxBottom = Math.max(rect.bottom, maxBottom);\r\n            }\r\n        );\r\n\r\n        const widthBorderGap = 100;\r\n        const widthDiff = canvasRect.width - (maxRight - canvasRect.left);\r\n        if (widthDiff < widthBorderGap) {\r\n            let growWidth = widthBorderGap;\r\n            if(widthDiff < 0) {\r\n                growWidth += Math.abs(widthDiff);\r\n            }\r\n            this.getCanvasContentElement().style.minWidth = `${canvasRect.width + growWidth}px`;\r\n            if (this.options.options.centerOnResize) {\r\n                this.render(flow, true, true);\r\n            }\r\n        } else if(widthDiff > widthBorderGap) {\r\n            var totalTreeWidth = this.getTotalTreeWidth(flow);\r\n            if(this.isNestedCanvas()) {\r\n                this.getCanvasContentElement().style.minWidth = `${totalTreeWidth + widthBorderGap}px`;\r\n                if (this.options.options.centerOnResize) {\r\n                    this.render(flow, true, true);\r\n                }\r\n            } else if(this.getCanvasContentElement().style.minWidth) {\r\n                // reset normal canvas width if auto width set\r\n                this.getCanvasContentElement().style.minWidth = null;\r\n                if (this.options.options.centerOnResize) {\r\n                    this.render(flow, true, true);\r\n                }\r\n            }\r\n        }\r\n        \r\n        const heightBorderGap = 50;\r\n        const heightDiff = canvasRect.height - (maxBottom - canvasRect.top);\r\n        if (heightDiff < heightBorderGap) {\r\n            let growHeight = heightBorderGap;\r\n            if(heightDiff < 0) {\r\n                growHeight += Math.abs(heightDiff);\r\n            }\r\n            this.getCanvasContentElement().style.minHeight = `${canvasRect.height + growHeight}px`;\r\n        } else if(heightDiff > heightBorderGap){\r\n            if(this.isNestedCanvas()) {\r\n                let shrinkHeight = heightDiff - heightBorderGap;\r\n                this.getCanvasContentElement().style.minHeight = `${canvasRect.height - shrinkHeight}px`;\r\n            } else if(this.getCanvasContentElement().style.minHeight) {\r\n                // reset normal canvas height if auto height set\r\n                this.getCanvasContentElement().style.minHeight = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    private getTotalTreeWidth(flow: CanvasFlow): number {\r\n        let totalTreeWidth = 0;\r\n        const rootWidth = flow.rootStep.getCurrentRect().width / this.scale;\r\n        flow.rootStep.children.forEach(child => {\r\n            let totalChildWidth = child.getNodeTreeWidth(this.getStepGap());\r\n            totalTreeWidth += totalChildWidth / this.scale;\r\n        });\r\n        totalTreeWidth += (flow.rootStep.children.length - 1) * this.getStepGap();\r\n        // total tree width doesn't give root width\r\n        return Math.max(totalTreeWidth, rootWidth);\r\n    }\r\n\r\n    private findBestMatchForSteps(dragStep: NgFlowchart.Step, event: DragEvent, steps: ReadonlyArray<NgFlowchartStepComponent>): DropProximity | null {\r\n        const absXY = [event.clientX, event.clientY];\r\n\r\n        let bestMatch: DropProximity = null;\r\n\r\n        for (let i = 0; i < steps.length; i++) {\r\n\r\n            const step = steps[i];\r\n\r\n            if (step.isHidden()) {\r\n                continue;\r\n            }\r\n\r\n            const position = this.findDropLocationForHover(absXY, step, dragStep);\r\n            if (position) {\r\n                if (position == 'deadzone') {\r\n                    bestMatch = null;\r\n                    break;\r\n                }\r\n                //if this step is closer than previous best match then we have a new best\r\n                else if (bestMatch == null || bestMatch.proximity > position.proximity) {\r\n                    bestMatch = position;\r\n                }\r\n            }\r\n        }\r\n\r\n        return bestMatch\r\n    }\r\n\r\n    public findAndShowClosestDrop(dragStep: NgFlowchart.Step, event: DragEvent, steps: ReadonlyArray<NgFlowchartStepComponent>): NgFlowchart.DropTarget {\r\n        if (!steps || steps.length == 0) {\r\n            return;\r\n        }\r\n\r\n        let bestMatch: DropProximity = this.findBestMatchForSteps(dragStep, event, steps);\r\n\r\n        // TODO make this more efficient. two loops\r\n        steps.forEach(step => {\r\n            if (bestMatch == null || step.nativeElement.id !== bestMatch.step.nativeElement.id) {\r\n\r\n                step.clearHoverIcons();\r\n            }\r\n        })\r\n\r\n        if (!bestMatch) {\r\n            return;\r\n        }\r\n\r\n        bestMatch.step.showHoverIcon(bestMatch.position);\r\n\r\n        return {\r\n            step: bestMatch.step,\r\n            position: bestMatch.position\r\n        };\r\n    }\r\n\r\n    public showSnaps(dragStep: NgFlowchart.PendingStep) {\r\n\r\n\r\n    }\r\n\r\n    public clearAllSnapIndicators(steps: ReadonlyArray<NgFlowchartStepComponent>) {\r\n        steps.forEach(\r\n            step => step.clearHoverIcons()\r\n        )\r\n    }\r\n\r\n    private setRootPosition(step: NgFlowchartStepComponent, dragEvent?: DragEvent) {\r\n\r\n        if (!dragEvent) {\r\n            const canvasTop = this.getCanvasTopCenterPosition(step.nativeElement);\r\n            step.zsetPosition(canvasTop, true)\r\n            return;\r\n        }\r\n\r\n        switch (this.options.options.rootPosition) {\r\n            case 'CENTER':\r\n                const canvasCenter = this.getCanvasCenterPosition();\r\n                step.zsetPosition(canvasCenter, true);\r\n                return;\r\n            case 'TOP_CENTER':\r\n                const canvasTop = this.getCanvasTopCenterPosition(step.nativeElement);\r\n                step.zsetPosition(canvasTop, true)\r\n                return;\r\n            default:\r\n                const relativeXY = this.getRelativeXY(dragEvent);\r\n                step.zsetPosition(relativeXY, true);\r\n                return;\r\n        }\r\n    }\r\n\r\n    private getRelativeXY(dragEvent: DragEvent) {\r\n        const canvasRect = this.getCanvasContentElement().getBoundingClientRect();\r\n\r\n        return [\r\n            dragEvent.clientX - canvasRect.left,\r\n            dragEvent.clientY - canvasRect.top\r\n        ]\r\n    }\r\n\r\n    private getCanvasTopCenterPosition(htmlRootElement: HTMLElement) {\r\n        const canvasRect = this.getCanvasContentElement().getBoundingClientRect();\r\n        const rootElementHeight = htmlRootElement.getBoundingClientRect().height\r\n        const yCoord = rootElementHeight / 2 + this.options.options.stepGap\r\n        const scaleYOffset = (1 - this.scale) * 100\r\n            \r\n        return [\r\n            canvasRect.width / (this.scale * 2),\r\n            yCoord + scaleYOffset\r\n        ]\r\n    }\r\n\r\n    private getCanvasCenterPosition() {\r\n        const canvasRect = this.getCanvasContentElement().getBoundingClientRect();\r\n        return [\r\n            canvasRect.width / 2,\r\n            canvasRect.height / 2\r\n        ]\r\n    }\r\n\r\n    private getCanvasContentElement(): HTMLElement {\r\n        const canvas = this.viewContainer.element.nativeElement as HTMLElement;\r\n        let canvasContent = canvas.getElementsByClassName(CONSTANTS.CANVAS_CONTENT_CLASS).item(0);\r\n        return canvasContent as HTMLElement;\r\n    }\r\n\r\n    private isNestedCanvas(): boolean {\r\n        if (this.viewContainer) {\r\n            const canvasWrapper = (this.viewContainer.element.nativeElement as HTMLElement).parentElement;\r\n            if (canvasWrapper) {\r\n                return canvasWrapper.classList.contains('ngflowchart-step-wrapper');\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public resetScale(flow: CanvasFlow) {\r\n        this.setScale(flow, 1)\r\n    }\r\n\r\n    public scaleUp(flow: CanvasFlow, step? : number) {\r\n        const newScale = this.scale + (this.scale * step || this.options.options.zoom.defaultStep)\r\n        this.setScale(flow, newScale)\r\n       \r\n    }\r\n\r\n    public scaleDown(flow: CanvasFlow, step? : number) {\r\n        const newScale = this.scale - (this.scale * step || this.options.options.zoom.defaultStep)\r\n        this.setScale(flow, newScale)\r\n    }\r\n\r\n    public setScale(flow: CanvasFlow, scaleValue: number) {\r\n        const minDimAdjust = `${1/scaleValue * 100}%`\r\n\r\n        const canvasContent = this.getCanvasContentElement()\r\n\r\n        canvasContent.style.transform = `scale(${scaleValue})`;\r\n        canvasContent.style.minHeight = minDimAdjust\r\n        canvasContent.style.minWidth = minDimAdjust\r\n        canvasContent.style.transformOrigin = 'top left'\r\n        canvasContent.classList.add('scaling')\r\n\r\n        this.scale = scaleValue\r\n        this.render(flow, true)\r\n\r\n        if(this.options.callbacks?.afterScale) {\r\n            this.options.callbacks.afterScale(this.scale)\r\n        }\r\n        \r\n        this.scaleDebounceTimer && clearTimeout(this.scaleDebounceTimer)\r\n        this.scaleDebounceTimer = setTimeout(() => {\r\n            canvasContent.classList.remove('scaling')\r\n        }, 300)\r\n\r\n    }\r\n\r\n\r\n}","import { Injectable } from \"@angular/core\";\r\nimport { NgFlowchart } from '../model/flow.model';\r\n\r\n\r\n\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\nexport class DropDataService {\r\n\r\n    dragStep: NgFlowchart.PendingStep | NgFlowchart.MoveStep;\r\n\r\n    constructor() {\r\n    }\r\n\r\n    public setDragStep(ref: NgFlowchart.PendingStep) {\r\n        this.dragStep = ref;\r\n    }\r\n\r\n    public getDragStep() {\r\n        return this.dragStep;\r\n    }\r\n}","import { Injectable, TemplateRef, Type } from '@angular/core';\r\nimport { NgFlowchartStepComponent } from './ng-flowchart-step/ng-flowchart-step.component';\r\n\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\nexport class NgFlowchartStepRegistry {\r\n    \r\n    private registry = new Map<string, Type<NgFlowchartStepComponent> | TemplateRef<any>>();\r\n    \r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Register a step implementation. Only needed if you are uploading a flow from json\r\n     * @param type The unique type of the step\r\n     * @param step The step templateRef or component type to create for this key\r\n     */\r\n    registerStep(type: string, step: Type<NgFlowchartStepComponent> | TemplateRef<any>) {\r\n        this.registry.set(type, step);\r\n    }\r\n\r\n    getStepImpl(type: string): Type<NgFlowchartStepComponent> | TemplateRef<any> | null {\r\n        return this.registry.get(type);\r\n    }\r\n\r\n\r\n}","import { ComponentFactoryResolver, ComponentRef, Injectable, TemplateRef, Type, ViewContainerRef } from '@angular/core';\r\nimport { NgFlowchart } from '../model/flow.model';\r\nimport { NgFlowchartCanvasService } from '../ng-flowchart-canvas.service';\r\nimport { NgFlowchartStepRegistry } from '../ng-flowchart-step-registry.service';\r\nimport { NgFlowchartStepComponent } from '../ng-flowchart-step/ng-flowchart-step.component';\r\nimport { DropDataService } from './dropdata.service';\r\n\r\n/**\r\n * This service handles adding new steps to the canvas\r\n */\r\n@Injectable()\r\nexport class StepManagerService {\r\n\r\n  private viewContainer: ViewContainerRef;\r\n\r\n  constructor(private componentFactoryResolver: ComponentFactoryResolver, private registry: NgFlowchartStepRegistry) {\r\n\r\n  }\r\n\r\n  public init(viewContainer: ViewContainerRef) {\r\n    this.viewContainer = viewContainer;\r\n  }\r\n\r\n  public createFromRegistry(id: string, type: string, data: any, canvas: NgFlowchartCanvasService): ComponentRef<NgFlowchartStepComponent> {\r\n    let templateComp = this.registry.getStepImpl(type);\r\n    let compRef: ComponentRef<NgFlowchartStepComponent>;\r\n    if (templateComp instanceof TemplateRef || templateComp instanceof Type) {\r\n      compRef = this.create({\r\n        template: templateComp,\r\n        type: type,\r\n        data: data\r\n      }, canvas);\r\n    }\r\n    else {\r\n      throw 'Invalid registry implementation found for type ' + type;\r\n    }\r\n\r\n    compRef.instance.setId(id);\r\n    return compRef;\r\n  }\r\n\r\n  public create(pendingStep: NgFlowchart.PendingStep, canvas: NgFlowchartCanvasService): ComponentRef<NgFlowchartStepComponent> {\r\n    let componentRef: ComponentRef<NgFlowchartStepComponent>;\r\n\r\n    if (pendingStep.template instanceof TemplateRef) {\r\n      const factory = this.componentFactoryResolver.resolveComponentFactory(NgFlowchartStepComponent);\r\n      componentRef = this.viewContainer.createComponent<NgFlowchartStepComponent>(factory);\r\n      componentRef.instance.contentTemplate = pendingStep.template;\r\n      \r\n    }\r\n    else {\r\n      const factory = this.componentFactoryResolver.resolveComponentFactory(pendingStep.template);\r\n      componentRef = this.viewContainer.createComponent<any>(factory);\r\n    }\r\n    \r\n    componentRef.instance.data = JSON.parse(JSON.stringify(pendingStep.data));\r\n    componentRef.instance.type = pendingStep.type;\r\n    componentRef.instance.canvas = canvas;\r\n    componentRef.instance.compRef = componentRef;\r\n    componentRef.instance.init(\r\n      componentRef.injector.get(DropDataService),\r\n      componentRef.injector.get(ViewContainerRef),\r\n      componentRef.injector.get(ComponentFactoryResolver)\r\n    )\r\n    \r\n\r\n    return componentRef;\r\n  }\r\n}\r\n","import { ComponentRef, Injectable, ViewContainerRef } from '@angular/core';\r\nimport { NgFlowchart } from './model/flow.model';\r\nimport { NgFlowchartStepComponent } from './ng-flowchart-step/ng-flowchart-step.component';\r\nimport { CanvasRendererService } from './services/canvas-renderer.service';\r\nimport { DropDataService as DragService } from './services/dropdata.service';\r\nimport { OptionsService } from './services/options.service';\r\nimport { StepManagerService } from './services/step-manager.service';\r\n\r\ntype DropResponse = {\r\n  added: boolean,\r\n  prettyRender: boolean\r\n}\r\n\r\nexport class CanvasFlow {\r\n  rootStep: NgFlowchartStepComponent;\r\n\r\n  // steps from this canvas only\r\n  private _steps: NgFlowchartStepComponent[] = [];\r\n\r\n  hasRoot() {\r\n    return !!this.rootStep;\r\n  }\r\n\r\n  addStep(step: NgFlowchartStepComponent) {\r\n    this._steps.push(step)\r\n  }\r\n\r\n  removeStep(step: NgFlowchartStepComponent) {\r\n\r\n    let index = this._steps.findIndex(ele => ele.id == step.id);\r\n    if (index >= 0) {\r\n      this._steps.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  get steps(): ReadonlyArray<NgFlowchartStepComponent> {\r\n    return this._steps;\r\n  }\r\n\r\n  constructor() {\r\n\r\n  }\r\n}\r\n\r\n@Injectable()\r\nexport class NgFlowchartCanvasService {\r\n\r\n  viewContainer: ViewContainerRef;\r\n  isDragging: boolean = false;\r\n\r\n  currentDropTarget: NgFlowchart.DropTarget;\r\n\r\n  flow: CanvasFlow = new CanvasFlow();\r\n\r\n  _disabled: boolean = false;\r\n\r\n  get disabled() {\r\n    return this._disabled;\r\n  }\r\n\r\n  noParentError = {\r\n    code: 'NO_PARENT',\r\n    message: 'Step was not dropped under a parent and is not the root node'\r\n  };\r\n\r\n  constructor(\r\n    private drag: DragService,\r\n    public options: OptionsService,\r\n    private renderer: CanvasRendererService,\r\n    private stepmanager: StepManagerService\r\n  ) {\r\n\r\n\r\n  }\r\n\r\n  public init(view: ViewContainerRef) {\r\n    this.viewContainer = view;\r\n    this.renderer.init(view);\r\n    this.stepmanager.init(view);\r\n\r\n    //hack to load the css\r\n    let ref = this.stepmanager.create({\r\n      template: NgFlowchartStepComponent,\r\n      type: '',\r\n      data: null\r\n    }, this);\r\n    const i = this.viewContainer.indexOf(ref.hostView)\r\n    this.viewContainer.remove(i);\r\n\r\n  }\r\n\r\n  public moveStep(drag: DragEvent, id: any) {\r\n    this.renderer.clearAllSnapIndicators(this.flow.steps);\r\n\r\n    let step: NgFlowchartStepComponent = this.flow.steps.find(step => step.nativeElement.id === id);\r\n    let error = {};\r\n    if(!step) {\r\n      // step cannot be moved if not in this canvas\r\n      return;\r\n    }\r\n    if (step.canDrop(this.currentDropTarget, error)) {\r\n      if (step.isRootElement()) {\r\n        this.renderer.updatePosition(step, drag);\r\n        this.renderer.render(this.flow);\r\n      }\r\n      else if (this.currentDropTarget) {\r\n        const response = this.addStepToFlow(step, this.currentDropTarget, true);\r\n        this.renderer.render(this.flow, response.prettyRender);\r\n      }\r\n      else {\r\n        this.moveError(step, this.noParentError);\r\n      }\r\n      if (this.options.callbacks?.onDropStep && (this.currentDropTarget || step.isRootElement())) {\r\n        this.options.callbacks.onDropStep({\r\n          isMove: true,\r\n          step: step,\r\n          parent: step.parent\r\n        })\r\n      }\r\n    }\r\n    else {\r\n      this.moveError(step, error);\r\n    }\r\n\r\n  }\r\n\r\n\r\n\r\n  public async onDrop(drag: DragEvent) {\r\n    this.renderer.clearAllSnapIndicators(this.flow.steps);\r\n\r\n    if (this.flow.hasRoot() && !this.currentDropTarget) {\r\n      this.dropError(this.noParentError);\r\n      return;\r\n    }\r\n\r\n    //TODO just pass dragStep here, but come up with a better name and move the type to flow.model\r\n    let componentRef = await this.createStep(this.drag.dragStep as NgFlowchart.PendingStep);\r\n\r\n    const dropTarget = this.currentDropTarget || null;\r\n    let error = {};\r\n    if (componentRef.instance.canDrop(dropTarget, error)) {\r\n      if (!this.flow.hasRoot()) {\r\n        this.renderer.renderRoot(componentRef, drag);\r\n        this.setRoot(componentRef.instance);\r\n      }\r\n      else {\r\n         // if root is replaced by another step, rerender root to proper position\r\n         if(dropTarget.step.isRootElement() && dropTarget.position === 'ABOVE') {\r\n          this.renderer.renderRoot(componentRef, drag);\r\n        }\r\n        this.addChildStep(componentRef, dropTarget);\r\n      }\r\n\r\n      if (this.options.callbacks?.onDropStep) {\r\n        this.options.callbacks.onDropStep({\r\n          step: componentRef.instance,\r\n          isMove: false,\r\n          parent: componentRef.instance.parent\r\n        })\r\n      }\r\n    }\r\n    else {\r\n      const i = this.viewContainer.indexOf(componentRef.hostView)\r\n      this.viewContainer.remove(i);\r\n      this.dropError(error);\r\n    }\r\n  }\r\n\r\n\r\n  public onDragStart(drag: DragEvent) {\r\n\r\n    this.isDragging = true;\r\n\r\n    this.currentDropTarget = this.renderer.findAndShowClosestDrop(this.drag.dragStep, drag, this.flow.steps);\r\n  }\r\n\r\n  public createStepFromType(id: string, type: string, data: any): Promise<ComponentRef<NgFlowchartStepComponent>> {\r\n    let compRef = this.stepmanager.createFromRegistry(id, type, data, this);\r\n    return new Promise((resolve) => {\r\n      let sub = compRef.instance.viewInit.subscribe(async () => {\r\n        sub.unsubscribe();\r\n        setTimeout(() => {\r\n          compRef.instance.onUpload(data)\r\n        })\r\n        resolve(compRef);\r\n      })\r\n    })\r\n  }\r\n\r\n  public createStep(pending: NgFlowchart.PendingStep): Promise<ComponentRef<NgFlowchartStepComponent>> {\r\n    let componentRef: ComponentRef<NgFlowchartStepComponent>;\r\n\r\n    componentRef = this.stepmanager.create(pending, this);\r\n\r\n    return new Promise((resolve) => {\r\n      let sub = componentRef.instance.viewInit.subscribe(() => {\r\n        sub.unsubscribe();\r\n        resolve(componentRef);\r\n      }, error => console.error(error))\r\n    })\r\n  }\r\n\r\n  public resetScale() {\r\n    if(this.options.options.zoom.mode === 'DISABLED') {\r\n      return\r\n    }\r\n    this.renderer.resetScale(this.flow)\r\n  }\r\n\r\n  public scaleUp(step?: number) {\r\n    if(this.options.options.zoom.mode === 'DISABLED') {\r\n      return\r\n    }\r\n    this.renderer.scaleUp(this.flow, step);\r\n\r\n  }\r\n\r\n  public scaleDown(step?: number) {\r\n    if(this.options.options.zoom.mode === 'DISABLED') {\r\n      return\r\n    }\r\n    this.renderer.scaleDown(this.flow, step);\r\n\r\n  }\r\n\r\n  public setScale(scaleValue: number) {\r\n    if(this.options.options.zoom.mode === 'DISABLED') {\r\n      return\r\n    }\r\n    this.renderer.setScale(this.flow, scaleValue)\r\n  }\r\n\r\n\r\n  addChildStep(componentRef: ComponentRef<NgFlowchartStepComponent>, dropTarget: NgFlowchart.DropTarget) {\r\n    this.addToCanvas(componentRef);\r\n    const response = this.addStepToFlow(componentRef.instance, dropTarget);\r\n    this.renderer.render(this.flow, response.prettyRender);\r\n  }\r\n\r\n  addToCanvas(componentRef: ComponentRef<NgFlowchartStepComponent>) {\r\n    this.renderer.renderNonRoot(componentRef);\r\n  }\r\n\r\n  reRender(pretty?: boolean) {\r\n    this.renderer.render(this.flow, pretty);\r\n  }\r\n\r\n  async upload(root: any) {\r\n    await this.uploadNode(root);\r\n    this.reRender(true);\r\n  }\r\n\r\n  private async uploadNode(node: any, parentNode?: NgFlowchartStepComponent): Promise<NgFlowchartStepComponent> {\r\n    if(!node){\r\n      // no node to upload when uploading empty nested flow\r\n      return;\r\n    }\r\n\r\n    let comp = await this.createStepFromType(node.id, node.type, node.data);\r\n    if (!parentNode) {\r\n      this.setRoot(comp.instance);\r\n      this.renderer.renderRoot(comp, null);\r\n    }\r\n    else {\r\n      this.renderer.renderNonRoot(comp);\r\n      this.flow.addStep(comp.instance);\r\n    }\r\n\r\n    for (let i = 0; i < node.children.length; i++) {\r\n      let child = node.children[i];\r\n      let childComp = await this.uploadNode(child, comp.instance);\r\n      comp.instance.children.push(childComp);\r\n      childComp.setParent(comp.instance, true);\r\n    }\r\n\r\n    return comp.instance;\r\n  }\r\n\r\n  private setRoot(step: NgFlowchartStepComponent, force: boolean = true) {\r\n    if (this.flow.hasRoot()) {\r\n      if (!force) {\r\n        console.warn('Already have a root and force is false');\r\n        return;\r\n      }\r\n\r\n      //reparent root\r\n      let oldRoot = this.flow.rootStep;\r\n      this.flow.rootStep = step;\r\n      step.zaddChild0(oldRoot);\r\n    }\r\n    else {\r\n      this.flow.rootStep = step;\r\n    }\r\n\r\n    this.flow.addStep(step);\r\n  }\r\n\r\n  private addStepToFlow(step: NgFlowchartStepComponent, dropTarget: NgFlowchart.DropTarget, isMove = false): DropResponse {\r\n\r\n    let response = {\r\n        added: false,\r\n        prettyRender: false,\r\n    };\r\n\r\n    switch (dropTarget.position) {\r\n      case 'ABOVE':\r\n        response = this.placeStepAbove(step, dropTarget.step);\r\n        break;\r\n      case 'BELOW':\r\n        response = this.placeStepBelow(step, dropTarget.step);\r\n        console.log(response, [...dropTarget.step.children])\r\n        break;\r\n      case 'LEFT':\r\n        response = this.placeStepAdjacent(step, dropTarget.step, true);\r\n        break;\r\n      case 'RIGHT':\r\n        response = this.placeStepAdjacent(step, dropTarget.step, false);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    if (!isMove && response.added) {\r\n      this.flow.addStep(step);\r\n    }\r\n    return response;\r\n  }\r\n\r\n  private placeStepBelow(newStep: NgFlowchartStepComponent, parentStep: NgFlowchartStepComponent): DropResponse {\r\n    return {\r\n      added: parentStep.zaddChild0(newStep),\r\n      prettyRender: false,\r\n    }\r\n  }\r\n\r\n  private placeStepAdjacent(newStep: NgFlowchartStepComponent, siblingStep: NgFlowchartStepComponent, isLeft: boolean = true): DropResponse {\r\n    if (siblingStep.parent) {\r\n      //find the adjacent steps index in the parents child array\r\n      const adjacentIndex = siblingStep.parent.children.findIndex(child => child.nativeElement.id == siblingStep.nativeElement.id);\r\n      siblingStep.parent.zaddChildSibling0(newStep, adjacentIndex + (isLeft ? 0 : 1));\r\n    }\r\n    else {\r\n      console.warn('Parallel actions must have a common parent');\r\n      return {\r\n        added: false,\r\n        prettyRender: false,\r\n      };\r\n    }\r\n    return {\r\n      added: true,\r\n      prettyRender: false,\r\n    };\r\n  }\r\n\r\n  private placeStepAbove(newStep: NgFlowchartStepComponent, childStep: NgFlowchartStepComponent): DropResponse {\r\n    let prettyRender = false\r\n    let newParent = childStep.parent;\r\n    if (newParent) {\r\n      //we want to remove child and insert our newStep at the same index\r\n      let index = newParent.removeChild(childStep);\r\n      newStep.zaddChild0(childStep);\r\n      newParent.zaddChild0(newStep);\r\n    }\r\n    else { // new root node\r\n      newStep.parent?.removeChild(newStep)\r\n      newStep.setParent(null, true)\r\n      \r\n      //if the new step was a direct child of the root step, we need to break that connection\r\n      childStep.removeChild(newStep)\r\n      this.setRoot(newStep);\r\n\r\n      prettyRender = true\r\n      \r\n    }\r\n    return {\r\n      added: true,\r\n      prettyRender\r\n    };\r\n  }\r\n\r\n  private dropError(error: NgFlowchart.ErrorMessage) {\r\n    if (this.options.callbacks?.onDropError) {\r\n      let parent = this.currentDropTarget?.position !== 'BELOW' ? this.currentDropTarget?.step.parent : this.currentDropTarget?.step\r\n      this.options.callbacks.onDropError({\r\n        step: (this.drag.dragStep as NgFlowchart.PendingStep),\r\n        parent: parent || null,\r\n        error: error\r\n      })\r\n    }\r\n  }\r\n\r\n  private moveError(step: NgFlowchartStepComponent, error) {\r\n    if (this.options.callbacks?.onMoveError) {\r\n      let parent = this.currentDropTarget?.position !== 'BELOW' ? this.currentDropTarget?.step.parent : this.currentDropTarget?.step\r\n      this.options.callbacks.onMoveError({\r\n        step: {\r\n          instance: step,\r\n          type: step.type,\r\n          data: step.data\r\n        },\r\n        parent: parent,\r\n        error: error\r\n      })\r\n    }\r\n  }\r\n}\r\n","import { AfterViewInit, Directive, ElementRef, HostBinding, HostListener, Input, OnDestroy, OnInit, ViewContainerRef } from '@angular/core';\r\nimport { NgFlowchart } from './model/flow.model';\r\nimport { CONSTANTS } from './model/flowchart.constants';\r\nimport { NgFlowchartCanvasService } from './ng-flowchart-canvas.service';\r\nimport { CanvasRendererService } from './services/canvas-renderer.service';\r\nimport { OptionsService } from './services/options.service';\r\nimport { StepManagerService } from './services/step-manager.service';\r\n\r\n\r\n\r\n@Directive({\r\n    selector: '[ngFlowchartCanvas]',\r\n    providers: [\r\n        NgFlowchartCanvasService,\r\n        StepManagerService,\r\n        OptionsService,\r\n        CanvasRendererService\r\n    ]\r\n})\r\nexport class NgFlowchartCanvasDirective implements OnInit, OnDestroy, AfterViewInit {\r\n\r\n    @HostListener('drop', ['$event'])\r\n    protected onDrop(event: DragEvent) {\r\n        if (this._disabled) { return; }\r\n\r\n        // its possible multiple canvases exist so make sure we only move/drop on the closest one\r\n        const closestCanvasId = (event.target as HTMLElement).closest('.ngflowchart-canvas-content')?.id\r\n        if (this._id !== closestCanvasId) {\r\n            return;\r\n        }\r\n\r\n        const type = event.dataTransfer.getData('type');\r\n        if ('FROM_CANVAS' == type) {\r\n            this.canvas.moveStep(event, event.dataTransfer.getData('id'));\r\n        }\r\n        else {\r\n            this.canvas.onDrop(event);\r\n        }\r\n\r\n    }\r\n\r\n    @HostListener('dragover', ['$event'])\r\n    protected onDragOver(event: DragEvent) {\r\n        event.preventDefault();\r\n        if (this._disabled) { return; }\r\n        this.canvas.onDragStart(event);\r\n    }\r\n\r\n    _options: NgFlowchart.Options;\r\n    _callbacks: NgFlowchart.Callbacks;\r\n\r\n    @HostListener('window:resize', ['$event'])\r\n    protected onResize(event) {\r\n        if (this._options.centerOnResize) {\r\n            this.canvas.reRender(true);\r\n        }\r\n    }\r\n\r\n    @HostListener('wheel', ['$event'])\r\n    protected onZoom(event) {\r\n        if (this._options.zoom.mode === 'WHEEL') {\r\n            this.adjustWheelScale(event)\r\n        }\r\n    }\r\n\r\n    @Input('ngFlowchartCallbacks')\r\n    set callbacks(callbacks: NgFlowchart.Callbacks) {\r\n        this.optionService.setCallbacks(callbacks);\r\n    }\r\n\r\n    @Input('ngFlowchartOptions')\r\n    set options(options: NgFlowchart.Options) {\r\n        this.optionService.setOptions(options);\r\n        this._options = this.optionService.options;\r\n        this.canvas.reRender();\r\n\r\n    }\r\n\r\n    get options() {\r\n        return this._options\r\n    }\r\n\r\n    @Input('disabled')\r\n    @HostBinding('attr.disabled')\r\n    set disabled(val: boolean) {\r\n        this._disabled = val !== false;\r\n        if (this.canvas) {\r\n            this.canvas._disabled = this._disabled;\r\n        }\r\n    }\r\n\r\n    get disabled() {\r\n        return this._disabled;\r\n    }\r\n\r\n    private _disabled: boolean = false;\r\n    private _id: string = null\r\n    private canvasContent: HTMLElement;\r\n\r\n    constructor(\r\n        protected canvasEle: ElementRef<HTMLElement>,\r\n        private viewContainer: ViewContainerRef,\r\n        private canvas: NgFlowchartCanvasService,\r\n        private optionService: OptionsService\r\n    ) {\r\n\r\n        this.canvasEle.nativeElement.classList.add(CONSTANTS.CANVAS_CLASS);\r\n        this.canvasContent = this.createCanvasContent(this.viewContainer);\r\n        this._id = this.canvasContent.id\r\n\r\n    }\r\n\r\n    ngOnInit() {\r\n        this.canvas.init(this.viewContainer);\r\n        if (!this._options) {\r\n            this.options = new NgFlowchart.Options();\r\n        }\r\n\r\n        this.canvas._disabled = this._disabled;\r\n    }\r\n\r\n    ngAfterViewInit() {\r\n\r\n    }\r\n\r\n    ngOnDestroy() {\r\n\r\n        for (let i = 0; i < this.viewContainer.length; i++) {\r\n            this.viewContainer.remove(i)\r\n        }\r\n        this.canvasEle.nativeElement.remove()\r\n        this.viewContainer.element.nativeElement.remove()\r\n        this.viewContainer = undefined\r\n    }\r\n\r\n    private createCanvasContent(viewContainer: ViewContainerRef): HTMLElement {\r\n        const canvasId = 'c' + Date.now();\r\n\r\n        let canvasEle = viewContainer.element.nativeElement as HTMLElement;\r\n        let canvasContent = document.createElement('div');\r\n        canvasContent.id = canvasId;\r\n        canvasContent.classList.add(CONSTANTS.CANVAS_CONTENT_CLASS);\r\n        canvasEle.appendChild(canvasContent);\r\n        return canvasContent\r\n    }\r\n\r\n    /**\r\n     * Returns the Flow object representing this flow chart.\r\n     */\r\n    public getFlow() {\r\n        return new NgFlowchart.Flow(this.canvas);\r\n    }\r\n\r\n    public scaleDown() {\r\n        this.canvas.scaleDown()\r\n    }\r\n\r\n    public scaleUp() {\r\n        this.canvas.scaleUp()\r\n    }\r\n\r\n    public setScale(scaleValue: number) {\r\n        \r\n        const scaleVal = Math.max(0, scaleValue)\r\n        this.canvas.setScale(scaleVal)\r\n    }\r\n\r\n    private adjustWheelScale(event) {\r\n\r\n        if (this.canvas.flow.hasRoot()) {\r\n            event.preventDefault();\r\n            // scale down / zoom out\r\n            if (event.deltaY > 0) {\r\n                this.scaleDown()\r\n            }\r\n            // scale up / zoom in\r\n            else if (event.deltaY < 0) {\r\n                this.scaleUp()\r\n            }\r\n\r\n        }\r\n    };\r\n}","import { AfterViewInit, Directive, ElementRef, HostListener, Input } from '@angular/core';\r\nimport { NgFlowchart } from './model/flow.model';\r\nimport { DropDataService } from './services/dropdata.service';\r\n\r\n@Directive({\r\n    selector: '[ngFlowchartStep]'\r\n})\r\nexport class NgFlowchartStepDirective implements AfterViewInit {\r\n\r\n    @HostListener('dragstart', ['$event'])\r\n    onDragStart(event: DragEvent) {\r\n        this.data.setDragStep(this.flowStep);\r\n        event.dataTransfer.setData('type', 'FROM_PALETTE');\r\n    }\r\n\r\n    @HostListener('dragend', ['$event'])\r\n    onDragEnd(event: DragEvent) {\r\n        \r\n        this.data.setDragStep(null);\r\n       \r\n    }\r\n\r\n    @Input('ngFlowchartStep')\r\n    flowStep: NgFlowchart.PendingStep;\r\n\r\n    constructor(\r\n        protected element: ElementRef<HTMLElement>,\r\n        private data: DropDataService\r\n    ) {\r\n        this.element.nativeElement.setAttribute('draggable', 'true');\r\n    }\r\n\r\n    ngAfterViewInit() {\r\n    }\r\n}","import { CommonModule } from '@angular/common';\r\nimport { NgModule } from '@angular/core';\r\nimport { NgFlowchartArrowComponent } from './ng-flowchart-arrow/ng-flowchart-arrow.component';\r\nimport { NgFlowchartCanvasDirective } from './ng-flowchart-canvas.directive';\r\nimport { NgFlowchartStepDirective } from './ng-flowchart-step.directive';\r\nimport { NgFlowchartStepComponent } from './ng-flowchart-step/ng-flowchart-step.component';\r\n\r\n@NgModule({\r\n  declarations: [NgFlowchartCanvasDirective, NgFlowchartStepDirective, NgFlowchartStepComponent, NgFlowchartArrowComponent],\r\n  imports: [\r\n    CommonModule\r\n  ],\r\n  exports: [NgFlowchartCanvasDirective, NgFlowchartStepDirective, NgFlowchartStepComponent, NgFlowchartArrowComponent],\r\n  entryComponents: [\r\n    NgFlowchartStepComponent,\r\n    NgFlowchartArrowComponent\r\n  ]\r\n})\r\nexport class NgFlowchartModule { }\r\n"]}